<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/base.rb</title>
    <link href="screen.css" media="screen" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h3>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/base.rb</h3>
    <p>Generated on Thu Dec 17 11:11:17 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
    
    <hr />
      <pre>
        <span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here&apos;s a line marked as not executed.</span>
      </pre>
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <!-- alternate light/dark here -->
        <tr class='light'>
          <td>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/base.rb</td>
          <td class='lines_total'><tt>3158</tt></td>
          <td class='lines_code'><tt>1469</tt></td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_total'>79.89%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='80'></td>
                      <td class='uncovered' width='20'></td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_code'>59.56%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='60'/>
                      <td class='uncovered' width='40'/>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1"></a>1 require 'yaml'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2"></a>2 require 'set'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3"></a>3 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line4"></a>4 module ActiveRecord #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line5"></a>5   # Generic Active Record exception class.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line6"></a>6   class ActiveRecordError < StandardError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line7"></a>7   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line8"></a>8 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line9"></a>9   # Raised when the single-table inheritance mechanism fails to locate the subclass</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line10"></a>10   # (for example due to improper usage of column that +inheritance_column+ points to).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line11"></a>11   class SubclassNotFound < ActiveRecordError #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line12"></a>12   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line13"></a>13 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line14"></a>14   # Raised when an object assigned to an association has an incorrect type.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line15"></a>15   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line16"></a>16   #   class Ticket < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line17"></a>17   #     has_many :patches</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line18"></a>18   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line19"></a>19   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line20"></a>20   #   class Patch < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line21"></a>21   #     belongs_to :ticket</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line22"></a>22   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line23"></a>23   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line24"></a>24   #   # Comments are not patches, this assignment raises AssociationTypeMismatch.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line25"></a>25   #   @ticket.patches << Comment.new(:content => "Please attach tests to your patch.")</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line26"></a>26   class AssociationTypeMismatch < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line27"></a>27   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line28"></a>28 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line29"></a>29   # Raised when unserialized object's type mismatches one specified for serializable field.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line30"></a>30   class SerializationTypeMismatch < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line31"></a>31   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line32"></a>32 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line33"></a>33   # Raised when adapter not specified on connection (or configuration file <tt>config/database.yml</tt> misses adapter field).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line34"></a>34   class AdapterNotSpecified < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line35"></a>35   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line36"></a>36 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line37"></a>37   # Raised when Active Record cannot find database adapter specified in <tt>config/database.yml</tt> or programmatically.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line38"></a>38   class AdapterNotFound < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line39"></a>39   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line40"></a>40 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line41"></a>41   # Raised when connection to the database could not been established (for example when <tt>connection=</tt> is given a nil object).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line42"></a>42   class ConnectionNotEstablished < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line43"></a>43   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line44"></a>44 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line45"></a>45   # Raised when Active Record cannot find record by given id or set of ids.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line46"></a>46   class RecordNotFound < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line47"></a>47   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line48"></a>48 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line49"></a>49   # Raised by ActiveRecord::Base.save! and ActiveRecord::Base.create! methods when record cannot be</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line50"></a>50   # saved because record is invalid.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line51"></a>51   class RecordNotSaved < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line52"></a>52   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line53"></a>53 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line54"></a>54   # Raised when SQL statement cannot be executed by the database (for example, it's often the case for MySQL when Ruby driver used is too old).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line55"></a>55   class StatementInvalid < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line56"></a>56   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line57"></a>57 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line58"></a>58   # Raised when number of bind variables in statement given to <tt>:condition</tt> key (for example, when using +find+ method)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line59"></a>59   # does not match number of expected variables.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line60"></a>60   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line61"></a>61   # For example, in</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line62"></a>62   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line63"></a>63   #   Location.find :all, :conditions => ["lat = ? AND lng = ?", 53.7362]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line64"></a>64   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line65"></a>65   # two placeholders are given but only one variable to fill them.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line66"></a>66   class PreparedStatementInvalid < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line67"></a>67   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line68"></a>68 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line69"></a>69   # Raised on attempt to save stale record. Record is stale when it's being saved in another query after</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line70"></a>70   # instantiation, for example, when two users edit the same wiki page and one starts editing and saves</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line71"></a>71   # the page before the other.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line72"></a>72   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line73"></a>73   # Read more about optimistic locking in ActiveRecord::Locking module RDoc.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line74"></a>74   class StaleObjectError < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line75"></a>75   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line76"></a>76 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line77"></a>77   # Raised when association is being configured improperly or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line78"></a>78   # user tries to use offset and limit together with has_many or has_and_belongs_to_many associations.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line79"></a>79   class ConfigurationError < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line80"></a>80   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line81"></a>81 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line82"></a>82   # Raised on attempt to update record that is instantiated as read only.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line83"></a>83   class ReadOnlyRecord < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line84"></a>84   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line85"></a>85 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line86"></a>86   # ActiveRecord::Transactions::ClassMethods.transaction uses this exception</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line87"></a>87   # to distinguish a deliberate rollback from other exceptional situations.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line88"></a>88   # Normally, raising an exception will cause the +transaction+ method to rollback</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line89"></a>89   # the database transaction *and* pass on the exception. But if you raise an</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line90"></a>90   # ActiveRecord::Rollback exception, then the database transaction will be rolled back,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line91"></a>91   # without passing on the exception.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line92"></a>92   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line93"></a>93   # For example, you could do this in your controller to rollback a transaction:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line94"></a>94   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line95"></a>95   #   class BooksController < ActionController::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line96"></a>96   #     def create</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line97"></a>97   #       Book.transaction do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line98"></a>98   #         book = Book.new(params[:book])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line99"></a>99   #         book.save!</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line100"></a>100   #         if today_is_friday?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line101"></a>101   #           # The system must fail on Friday so that our support department</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line102"></a>102   #           # won't be out of job. We silently rollback this transaction</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line103"></a>103   #           # without telling the user.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line104"></a>104   #           raise ActiveRecord::Rollback, "Call tech support!"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line105"></a>105   #         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line106"></a>106   #       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line107"></a>107   #       # ActiveRecord::Rollback is the only exception that won't be passed on</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line108"></a>108   #       # by ActiveRecord::Base.transaction, so this line will still be reached</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line109"></a>109   #       # even on Friday.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line110"></a>110   #       redirect_to root_url</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line111"></a>111   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line112"></a>112   #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line113"></a>113   class Rollback < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line114"></a>114   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line115"></a>115 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line116"></a>116   # Raised when attribute has a name reserved by Active Record (when attribute has name of one of Active Record instance methods).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line117"></a>117   class DangerousAttributeError < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line118"></a>118   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line119"></a>119 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line120"></a>120   # Raised when you've tried to access a column which wasn't loaded by your finder.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line121"></a>121   # Typically this is because <tt>:select</tt> has been specified.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line122"></a>122   class MissingAttributeError < NoMethodError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line123"></a>123   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line124"></a>124 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line125"></a>125   # Raised when unknown attributes are supplied via mass assignment.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line126"></a>126   class UnknownAttributeError < NoMethodError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line127"></a>127   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line128"></a>128 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line129"></a>129   # Raised when an error occurred while doing a mass assignment to an attribute through the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line130"></a>130   # <tt>attributes=</tt> method. The exception has an +attribute+ property that is the name of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line131"></a>131   # offending attribute.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line132"></a>132   class AttributeAssignmentError < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line133"></a>133     attr_reader :exception, :attribute</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line134"></a>134     def initialize(message, exception, attribute)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line135"></a>135       @exception = exception</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line136"></a>136       @attribute = attribute</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line137"></a>137       @message = message</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line138"></a>138     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line139"></a>139   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line140"></a>140 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line141"></a>141   # Raised when there are multiple errors while doing a mass assignment through the +attributes+</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line142"></a>142   # method. The exception has an +errors+ property that contains an array of AttributeAssignmentError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line143"></a>143   # objects, each corresponding to the error while assigning to an attribute.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line144"></a>144   class MultiparameterAssignmentErrors < ActiveRecordError</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line145"></a>145     attr_reader :errors</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line146"></a>146     def initialize(errors)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line147"></a>147       @errors = errors</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line148"></a>148     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line149"></a>149   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line150"></a>150 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line151"></a>151   # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line152"></a>152   # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line153"></a>153   # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line154"></a>154   # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line155"></a>155   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line156"></a>156   # See the mapping rules in table_name and the full example in link:files/README.html for more insight.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line157"></a>157   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line158"></a>158   # == Creation</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line159"></a>159   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line160"></a>160   # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line161"></a>161   # you're receiving the data from somewhere else, like an HTTP request. It works like this:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line162"></a>162   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line163"></a>163   #   user = User.new(:name => "David", :occupation => "Code Artist")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line164"></a>164   #   user.name # => "David"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line165"></a>165   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line166"></a>166   # You can also use block initialization:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line167"></a>167   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line168"></a>168   #   user = User.new do |u|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line169"></a>169   #     u.name = "David"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line170"></a>170   #     u.occupation = "Code Artist"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line171"></a>171   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line172"></a>172   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line173"></a>173   # And of course you can just create a bare object and specify the attributes after the fact:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line174"></a>174   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line175"></a>175   #   user = User.new</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line176"></a>176   #   user.name = "David"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line177"></a>177   #   user.occupation = "Code Artist"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line178"></a>178   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line179"></a>179   # == Conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line180"></a>180   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line181"></a>181   # Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line182"></a>182   # The array form is to be used when the condition input is tainted and requires sanitization. The string form can</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line183"></a>183   # be used for statements that don't involve tainted data. The hash form works much like the array form, except</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line184"></a>184   # only equality and range is possible. Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line185"></a>185   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line186"></a>186   #   class User < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line187"></a>187   #     def self.authenticate_unsafely(user_name, password)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line188"></a>188   #       find(:first, :conditions => "user_name = '#{user_name}' AND password = '#{password}'")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line189"></a>189   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line190"></a>190   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line191"></a>191   #     def self.authenticate_safely(user_name, password)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line192"></a>192   #       find(:first, :conditions => [ "user_name = ? AND password = ?", user_name, password ])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line193"></a>193   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line194"></a>194   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line195"></a>195   #     def self.authenticate_safely_simply(user_name, password)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line196"></a>196   #       find(:first, :conditions => { :user_name => user_name, :password => password })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line197"></a>197   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line198"></a>198   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line199"></a>199   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line200"></a>200   # The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query and is thus susceptible to SQL-injection</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line201"></a>201   # attacks if the <tt>user_name</tt> and +password+ parameters come directly from an HTTP request. The <tt>authenticate_safely</tt>  and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line202"></a>202   # <tt>authenticate_safely_simply</tt> both will sanitize the <tt>user_name</tt> and +password+ before inserting them in the query,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line203"></a>203   # which will ensure that an attacker can't escape the query and fake the login (or worse).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line204"></a>204   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line205"></a>205   # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line206"></a>206   # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line207"></a>207   # the question marks with symbols and supplying a hash with values for the matching symbol keys:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line208"></a>208   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line209"></a>209   #   Company.find(:first, :conditions => [</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line210"></a>210   #     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line211"></a>211   #     { :id => 3, :name => "37signals", :division => "First", :accounting_date => '2005-01-01' }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line212"></a>212   #   ])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line213"></a>213   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line214"></a>214   # Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line215"></a>215   # operator. For instance:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line216"></a>216   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line217"></a>217   #   Student.find(:all, :conditions => { :first_name => "Harvey", :status => 1 })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line218"></a>218   #   Student.find(:all, :conditions => params[:student])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line219"></a>219   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line220"></a>220   # A range may be used in the hash to use the SQL BETWEEN operator:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line221"></a>221   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line222"></a>222   #   Student.find(:all, :conditions => { :grade => 9..12 })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line223"></a>223   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line224"></a>224   # An array may be used in the hash to use the SQL IN operator:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line225"></a>225   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line226"></a>226   #   Student.find(:all, :conditions => { :grade => [9,11,12] })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line227"></a>227   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line228"></a>228   # == Overwriting default accessors</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line229"></a>229   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line230"></a>230   # All column values are automatically available through basic accessors on the Active Record object, but sometimes you</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line231"></a>231   # want to specialize this behavior. This can be done by overwriting the default accessors (using the same</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line232"></a>232   # name as the attribute) and calling <tt>read_attribute(attr_name)</tt> and <tt>write_attribute(attr_name, value)</tt> to actually change things.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line233"></a>233   # Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line234"></a>234   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line235"></a>235   #   class Song < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line236"></a>236   #     # Uses an integer of seconds to hold the length of the song</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line237"></a>237   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line238"></a>238   #     def length=(minutes)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line239"></a>239   #       write_attribute(:length, minutes.to_i * 60)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line240"></a>240   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line241"></a>241   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line242"></a>242   #     def length</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line243"></a>243   #       read_attribute(:length) / 60</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line244"></a>244   #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line245"></a>245   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line246"></a>246   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line247"></a>247   # You can alternatively use <tt>self[:attribute]=(value)</tt> and <tt>self[:attribute]</tt> instead of <tt>write_attribute(:attribute, value)</tt> and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line248"></a>248   # <tt>read_attribute(:attribute)</tt> as a shorter form.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line249"></a>249   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line250"></a>250   # == Attribute query methods</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line251"></a>251   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line252"></a>252   # In addition to the basic accessors, query methods are also automatically available on the Active Record object.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line253"></a>253   # Query methods allow you to test whether an attribute value is present.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line254"></a>254   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line255"></a>255   # For example, an Active Record User with the <tt>name</tt> attribute has a <tt>name?</tt> method that you can call</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line256"></a>256   # to determine whether the user has a name:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line257"></a>257   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line258"></a>258   #   user = User.new(:name => "David")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line259"></a>259   #   user.name? # => true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line260"></a>260   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line261"></a>261   #   anonymous = User.new(:name => "")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line262"></a>262   #   anonymous.name? # => false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line263"></a>263   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line264"></a>264   # == Accessing attributes before they have been typecasted</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line265"></a>265   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line266"></a>266   # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line267"></a>267   # That can be done by using the <tt><attribute>_before_type_cast</tt> accessors that all attributes have. For example, if your Account model</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line268"></a>268   # has a <tt>balance</tt> attribute, you can call <tt>account.balance_before_type_cast</tt> or <tt>account.id_before_type_cast</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line269"></a>269   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line270"></a>270   # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line271"></a>271   # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line272"></a>272   # want.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line273"></a>273   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line274"></a>274   # == Dynamic attribute-based finders</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line275"></a>275   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line276"></a>276   # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line277"></a>277   # appending the name of an attribute to <tt>find_by_</tt>, <tt>find_last_by_</tt>, or <tt>find_all_by_</tt>, so you get finders like <tt>Person.find_by_user_name</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line278"></a>278   # <tt>Person.find_all_by_last_name</tt>, and <tt>Payment.find_by_transaction_id</tt>. So instead of writing</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line279"></a>279   # <tt>Person.find(:first, :conditions => ["user_name = ?", user_name])</tt>, you just do <tt>Person.find_by_user_name(user_name)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line280"></a>280   # And instead of writing <tt>Person.find(:all, :conditions => ["last_name = ?", last_name])</tt>, you just do <tt>Person.find_all_by_last_name(last_name)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line281"></a>281   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line282"></a>282   # It's also possible to use multiple attributes in the same find by separating them with "_and_", so you get finders like</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line283"></a>283   # <tt>Person.find_by_user_name_and_password</tt> or even <tt>Payment.find_by_purchaser_and_state_and_country</tt>. So instead of writing</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line284"></a>284   # <tt>Person.find(:first, :conditions => ["user_name = ? AND password = ?", user_name, password])</tt>, you just do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line285"></a>285   # <tt>Person.find_by_user_name_and_password(user_name, password)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line286"></a>286   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line287"></a>287   # It's even possible to use all the additional parameters to find. For example, the full interface for <tt>Payment.find_all_by_amount</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line288"></a>288   # is actually <tt>Payment.find_all_by_amount(amount, options)</tt>. And the full interface to <tt>Person.find_by_user_name</tt> is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line289"></a>289   # actually <tt>Person.find_by_user_name(user_name, options)</tt>. So you could call <tt>Payment.find_all_by_amount(50, :order => "created_on")</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line290"></a>290   # Also you may call <tt>Payment.find_last_by_amount(amount, options)</tt> returning the last record matching that amount and options.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line291"></a>291   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line292"></a>292   # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line293"></a>293   # <tt>find_or_create_by_</tt> and will return the object if it already exists and otherwise creates it, then returns it. Protected attributes won't be set unless they are given in a block. For example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line294"></a>294   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line295"></a>295   #   # No 'Summer' tag exists</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line296"></a>296   #   Tag.find_or_create_by_name("Summer") # equal to Tag.create(:name => "Summer")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line297"></a>297   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line298"></a>298   #   # Now the 'Summer' tag does exist</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line299"></a>299   #   Tag.find_or_create_by_name("Summer") # equal to Tag.find_by_name("Summer")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line300"></a>300   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line301"></a>301   #   # Now 'Bob' exist and is an 'admin'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line302"></a>302   #   User.find_or_create_by_name('Bob', :age => 40) { |u| u.admin = true }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line303"></a>303   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line304"></a>304   # Use the <tt>find_or_initialize_by_</tt> finder if you want to return a new record without saving it first. Protected attributes won't be set unless they are given in a block. For example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line305"></a>305   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line306"></a>306   #   # No 'Winter' tag exists</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line307"></a>307   #   winter = Tag.find_or_initialize_by_name("Winter")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line308"></a>308   #   winter.new_record? # true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line309"></a>309   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line310"></a>310   # To find by a subset of the attributes to be used for instantiating a new object, pass a hash instead of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line311"></a>311   # a list of parameters. For example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line312"></a>312   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line313"></a>313   #   Tag.find_or_create_by_name(:name => "rails", :creator => current_user)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line314"></a>314   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line315"></a>315   # That will either find an existing tag named "rails", or create a new one while setting the user that created it.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line316"></a>316   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line317"></a>317   # == Saving arrays, hashes, and other non-mappable objects in text columns</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line318"></a>318   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line319"></a>319   # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line320"></a>320   # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line321"></a>321   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line322"></a>322   #   class User < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line323"></a>323   #     serialize :preferences</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line324"></a>324   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line325"></a>325   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line326"></a>326   #   user = User.create(:preferences => { "background" => "black", "display" => large })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line327"></a>327   #   User.find(user.id).preferences # => { "background" => "black", "display" => large }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line328"></a>328   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line329"></a>329   # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line330"></a>330   # descendant of a class not in the hierarchy. Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line331"></a>331   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line332"></a>332   #   class User < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line333"></a>333   #     serialize :preferences, Hash</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line334"></a>334   #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line335"></a>335   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line336"></a>336   #   user = User.create(:preferences => %w( one two three ))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line337"></a>337   #   User.find(user.id).preferences    # raises SerializationTypeMismatch</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line338"></a>338   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line339"></a>339   # == Single table inheritance</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line340"></a>340   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line341"></a>341   # Active Record allows inheritance by storing the name of the class in a column that by default is named "type" (can be changed</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line342"></a>342   # by overwriting <tt>Base.inheritance_column</tt>). This means that an inheritance looking like this:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line343"></a>343   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line344"></a>344   #   class Company < ActiveRecord::Base; end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line345"></a>345   #   class Firm < Company; end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line346"></a>346   #   class Client < Company; end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line347"></a>347   #   class PriorityClient < Client; end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line348"></a>348   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line349"></a>349   # When you do <tt>Firm.create(:name => "37signals")</tt>, this record will be saved in the companies table with type = "Firm". You can then</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line350"></a>350   # fetch this row again using <tt>Company.find(:first, "name = '37signals'")</tt> and it will return a Firm object.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line351"></a>351   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line352"></a>352   # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line353"></a>353   # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line354"></a>354   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line355"></a>355   # Note, all the attributes for all the cases are kept in the same table. Read more:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line356"></a>356   # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line357"></a>357   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line358"></a>358   # == Connection to multiple databases in different models</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line359"></a>359   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line360"></a>360   # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line361"></a>361   # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line362"></a>362   # For example, if Course is an ActiveRecord::Base, but resides in a different database, you can just say <tt>Course.establish_connection</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line363"></a>363   # and Course and all of its subclasses will use this connection instead.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line364"></a>364   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line365"></a>365   # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line366"></a>366   # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line367"></a>367   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line368"></a>368   # == Exceptions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line369"></a>369   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line370"></a>370   # * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line371"></a>371   # * AdapterNotSpecified - The configuration hash used in <tt>establish_connection</tt> didn't include an</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line372"></a>372   #   <tt>:adapter</tt> key.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line373"></a>373   # * AdapterNotFound - The <tt>:adapter</tt> key used in <tt>establish_connection</tt> specified a non-existent adapter</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line374"></a>374   #   (or a bad spelling of an existing one).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line375"></a>375   # * AssociationTypeMismatch - The object assigned to the association wasn't of the type specified in the association definition.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line376"></a>376   # * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line377"></a>377   # * ConnectionNotEstablished+ - No connection has been established. Use <tt>establish_connection</tt> before querying.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line378"></a>378   # * RecordNotFound - No record responded to the +find+ method. Either the row with the given ID doesn't exist</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line379"></a>379   #   or the row didn't meet the additional restrictions. Some +find+ calls do not raise this exception to signal</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line380"></a>380   #   nothing was found, please check its documentation for further details.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line381"></a>381   # * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line382"></a>382   # * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line383"></a>383   #   <tt>attributes=</tt> method. The +errors+ property of this exception contains an array of AttributeAssignmentError</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line384"></a>384   #   objects that should be inspected to determine which attributes triggered the errors.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line385"></a>385   # * AttributeAssignmentError - An error occurred while doing a mass assignment through the <tt>attributes=</tt> method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line386"></a>386   #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line387"></a>387   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line388"></a>388   # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line389"></a>389   # So it's possible to assign a logger to the class through <tt>Base.logger=</tt> which will then be used by all</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line390"></a>390   # instances in the current object space.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line391"></a>391   class Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line392"></a>392     ##  </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line393"></a>393     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line394"></a>394     # Accepts a logger conforming to the interface of Log4r or the default Ruby 1.8+ Logger class, which is then passed</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line395"></a>395     # on to any new database connections made and which can be retrieved on both a class and instance level by calling +logger+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line396"></a>396     cattr_accessor :logger, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line397"></a>397 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line398"></a>398     def self.inherited(child) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line399"></a>399       @@subclasses[self] ||= []</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line400"></a>400       @@subclasses[self] << child</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line401"></a>401       super</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line402"></a>402     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line403"></a>403 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line404"></a>404     def self.reset_subclasses #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line405"></a>405       nonreloadables = []</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line406"></a>406       subclasses.each do |klass|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line407"></a>407         unless ActiveSupport::Dependencies.autoloaded? klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line408"></a>408           nonreloadables << klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line409"></a>409           next</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line410"></a>410         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line411"></a>411         klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line412"></a>412         klass.instance_methods(false).each { |m| klass.send :undef_method, m }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line413"></a>413       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line414"></a>414       @@subclasses = {}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line415"></a>415       nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) << klass }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line416"></a>416     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line417"></a>417 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line418"></a>418     @@subclasses = {}</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line419"></a>419 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line420"></a>420     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line421"></a>421     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line422"></a>422     # Contains the database configuration - as is typically stored in config/database.yml -</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line423"></a>423     # as a Hash.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line424"></a>424     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line425"></a>425     # For example, the following database.yml...</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line426"></a>426     # </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line427"></a>427     #   development:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line428"></a>428     #     adapter: sqlite3</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line429"></a>429     #     database: db/development.sqlite3</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line430"></a>430     #   </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line431"></a>431     #   production:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line432"></a>432     #     adapter: sqlite3</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line433"></a>433     #     database: db/production.sqlite3</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line434"></a>434     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line435"></a>435     # ...would result in ActiveRecord::Base.configurations to look like this:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line436"></a>436     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line437"></a>437     #   {</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line438"></a>438     #      'development' => {</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line439"></a>439     #         'adapter'  => 'sqlite3',</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line440"></a>440     #         'database' => 'db/development.sqlite3'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line441"></a>441     #      },</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line442"></a>442     #      'production' => {</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line443"></a>443     #         'adapter'  => 'sqlite3',</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line444"></a>444     #         'database' => 'db/production.sqlite3'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line445"></a>445     #      }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line446"></a>446     #   }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line447"></a>447     cattr_accessor :configurations, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line448"></a>448     @@configurations = {}</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line449"></a>449 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line450"></a>450     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line451"></a>451     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line452"></a>452     # Accessor for the prefix type that will be prepended to every primary key column name. The options are :table_name and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line453"></a>453     # :table_name_with_underscore. If the first is specified, the Product class will look for "productid" instead of "id" as</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line454"></a>454     # the primary column. If the latter is specified, the Product class will look for "product_id" instead of "id". Remember</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line455"></a>455     # that this is a global setting for all Active Records.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line456"></a>456     cattr_accessor :primary_key_prefix_type, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line457"></a>457     @@primary_key_prefix_type = nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line458"></a>458 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line459"></a>459     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line460"></a>460     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line461"></a>461     # Accessor for the name of the prefix string to prepend to every table name. So if set to "basecamp_", all</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line462"></a>462     # table names will be named like "basecamp_projects", "basecamp_people", etc. This is a convenient way of creating a namespace</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line463"></a>463     # for tables in a shared database. By default, the prefix is the empty string.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line464"></a>464     cattr_accessor :table_name_prefix, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line465"></a>465     @@table_name_prefix = ""</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line466"></a>466 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line467"></a>467     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line468"></a>468     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line469"></a>469     # Works like +table_name_prefix+, but appends instead of prepends (set to "_basecamp" gives "projects_basecamp",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line470"></a>470     # "people_basecamp"). By default, the suffix is the empty string.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line471"></a>471     cattr_accessor :table_name_suffix, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line472"></a>472     @@table_name_suffix = ""</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line473"></a>473 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line474"></a>474     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line475"></a>475     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line476"></a>476     # Indicates whether table names should be the pluralized versions of the corresponding class names.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line477"></a>477     # If true, the default table name for a Product class will be +products+. If false, it would just be +product+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line478"></a>478     # See table_name for the full rules on table/class naming. This is true, by default.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line479"></a>479     cattr_accessor :pluralize_table_names, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line480"></a>480     @@pluralize_table_names = true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line481"></a>481 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line482"></a>482     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line483"></a>483     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line484"></a>484     # Determines whether to use ANSI codes to colorize the logging statements committed by the connection adapter. These colors</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line485"></a>485     # make it much easier to overview things during debugging (when used through a reader like +tail+ and on a black background), but</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line486"></a>486     # may complicate matters if you use software like syslog. This is true, by default.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line487"></a>487     cattr_accessor :colorize_logging, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line488"></a>488     @@colorize_logging = true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line489"></a>489 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line490"></a>490     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line491"></a>491     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line492"></a>492     # Determines whether to use Time.local (using :local) or Time.utc (using :utc) when pulling dates and times from the database.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line493"></a>493     # This is set to :local by default.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line494"></a>494     cattr_accessor :default_timezone, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line495"></a>495     @@default_timezone = :local</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line496"></a>496 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line497"></a>497     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line498"></a>498     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line499"></a>499     # Specifies the format to use when dumping the database schema with Rails'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line500"></a>500     # Rakefile.  If :sql, the schema is dumped as (potentially database-</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line501"></a>501     # specific) SQL statements.  If :ruby, the schema is dumped as an</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line502"></a>502     # ActiveRecord::Schema file which can be loaded into any database that</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line503"></a>503     # supports migrations.  Use :ruby if you want to have different database</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line504"></a>504     # adapters for, e.g., your development and test environments.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line505"></a>505     cattr_accessor :schema_format , :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line506"></a>506     @@schema_format = :ruby</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line507"></a>507 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line508"></a>508     ##</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line509"></a>509     # :singleton-method:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line510"></a>510     # Specify whether or not to use timestamps for migration numbers</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line511"></a>511     cattr_accessor :timestamped_migrations , :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line512"></a>512     @@timestamped_migrations = true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line513"></a>513 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line514"></a>514     # Determine whether to store the full constant name including namespace when using STI</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line515"></a>515     superclass_delegating_accessor :store_full_sti_class</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line516"></a>516     self.store_full_sti_class = false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line517"></a>517 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line518"></a>518     # Stores the default scope for the class</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line519"></a>519     class_inheritable_accessor :default_scoping, :instance_writer => false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line520"></a>520     self.default_scoping = []</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line521"></a>521 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line522"></a>522     class << self # Class methods</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line523"></a>523       # Find operates with four different retrieval approaches:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line524"></a>524       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line525"></a>525       # * Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line526"></a>526       #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line527"></a>527       # * Find first - This will return the first record matched by the options used. These options can either be specific</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line528"></a>528       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line529"></a>529       #   <tt>Model.find(:first, *args)</tt> or its shortcut <tt>Model.first(*args)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line530"></a>530       # * Find last - This will return the last record matched by the options used. These options can either be specific</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line531"></a>531       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line532"></a>532       #   <tt>Model.find(:last, *args)</tt> or its shortcut <tt>Model.last(*args)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line533"></a>533       # * Find all - This will return all the records matched by the options used.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line534"></a>534       #   If no records are found, an empty array is returned. Use</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line535"></a>535       #   <tt>Model.find(:all, *args)</tt> or its shortcut <tt>Model.all(*args)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line536"></a>536       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line537"></a>537       # All approaches accept an options hash as their last parameter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line538"></a>538       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line539"></a>539       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line540"></a>540       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line541"></a>541       # * <tt>:conditions</tt> - An SQL fragment like "administrator = 1", <tt>[ "user_name = ?", username ]</tt>, or <tt>["user_name = :user_name", { :user_name => user_name }]</tt>. See conditions in the intro.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line542"></a>542       # * <tt>:order</tt> - An SQL fragment like "created_at DESC, name".</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line543"></a>543       # * <tt>:group</tt> - An attribute name by which the result should be grouped. Uses the <tt>GROUP BY</tt> SQL-clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line544"></a>544       # * <tt>:having</tt> - Combined with +:group+ this can be used to filter the records that a <tt>GROUP BY</tt> returns. Uses the <tt>HAVING</tt> SQL-clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line545"></a>545       # * <tt>:limit</tt> - An integer determining the limit on the number of rows that should be returned.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line546"></a>546       # * <tt>:offset</tt> - An integer determining the offset from where the rows should be fetched. So at 5, it would skip rows 0 through 4.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line547"></a>547       # * <tt>:joins</tt> - Either an SQL fragment for additional joins like "LEFT JOIN comments ON comments.post_id = id" (rarely needed),</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line548"></a>548       #   named associations in the same form used for the <tt>:include</tt> option, which will perform an <tt>INNER JOIN</tt> on the associated table(s),</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line549"></a>549       #   or an array containing a mixture of both strings and named associations.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line550"></a>550       #   If the value is a string, then the records will be returned read-only since they will have attributes that do not correspond to the table's columns.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line551"></a>551       #   Pass <tt>:readonly => false</tt> to override.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line552"></a>552       # * <tt>:include</tt> - Names associations that should be loaded alongside. The symbols named refer</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line553"></a>553       #   to already defined associations. See eager loading under Associations.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line554"></a>554       # * <tt>:select</tt> - By default, this is "*" as in "SELECT * FROM", but can be changed if you, for example, want to do a join but not</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line555"></a>555       #   include the joined columns. Takes a string with the SELECT SQL fragment (e.g. "id, name").</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line556"></a>556       # * <tt>:from</tt> - By default, this is the table name of the class, but can be changed to an alternate table name (or even the name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line557"></a>557       #   of a database view).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line558"></a>558       # * <tt>:readonly</tt> - Mark the returned records read-only so they cannot be saved or updated.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line559"></a>559       # * <tt>:lock</tt> - An SQL fragment like "FOR UPDATE" or "LOCK IN SHARE MODE".</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line560"></a>560       #   <tt>:lock => true</tt> gives connection's default exclusive lock, usually "FOR UPDATE".</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line561"></a>561       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line562"></a>562       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line563"></a>563       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line564"></a>564       #   # find by id</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line565"></a>565       #   Person.find(1)       # returns the object for ID = 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line566"></a>566       #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line567"></a>567       #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line568"></a>568       #   Person.find([1])     # returns an array for the object with ID = 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line569"></a>569       #   Person.find(1, :conditions => "administrator = 1", :order => "created_on DESC")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line570"></a>570       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line571"></a>571       # Note that returned records may not be in the same order as the ids you</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line572"></a>572       # provide since database rows are unordered. Give an explicit <tt>:order</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line573"></a>573       # to ensure the results are sorted.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line574"></a>574       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line575"></a>575       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line576"></a>576       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line577"></a>577       #   # find first</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line578"></a>578       #   Person.find(:first) # returns the first object fetched by SELECT * FROM people</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line579"></a>579       #   Person.find(:first, :conditions => [ "user_name = ?", user_name])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line580"></a>580       #   Person.find(:first, :conditions => [ "user_name = :u", { :u => user_name }])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line581"></a>581       #   Person.find(:first, :order => "created_on DESC", :offset => 5)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line582"></a>582       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line583"></a>583       #   # find last</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line584"></a>584       #   Person.find(:last) # returns the last object fetched by SELECT * FROM people</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line585"></a>585       #   Person.find(:last, :conditions => [ "user_name = ?", user_name])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line586"></a>586       #   Person.find(:last, :order => "created_on DESC", :offset => 5)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line587"></a>587       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line588"></a>588       #   # find all</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line589"></a>589       #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line590"></a>590       #   Person.find(:all, :conditions => [ "category IN (?)", categories], :limit => 50)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line591"></a>591       #   Person.find(:all, :conditions => { :friends => ["Bob", "Steve", "Fred"] }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line592"></a>592       #   Person.find(:all, :offset => 10, :limit => 10)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line593"></a>593       #   Person.find(:all, :include => [ :account, :friends ])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line594"></a>594       #   Person.find(:all, :group => "category")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line595"></a>595       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line596"></a>596       # Example for find with a lock: Imagine two concurrent transactions:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line597"></a>597       # each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line598"></a>598       # in two saves of <tt>person.visits = 3</tt>.  By locking the row, the second</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line599"></a>599       # transaction has to wait until the first is finished; we get the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line600"></a>600       # expected <tt>person.visits == 4</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line601"></a>601       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line602"></a>602       #   Person.transaction do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line603"></a>603       #     person = Person.find(1, :lock => true)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line604"></a>604       #     person.visits += 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line605"></a>605       #     person.save!</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line606"></a>606       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line607"></a>607       def find(*args)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line608"></a>608         options = args.extract_options!</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line609"></a>609         validate_find_options(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line610"></a>610         set_readonly_option!(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line611"></a>611 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line612"></a>612         case args.first</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line613"></a>613           when :first then find_initial(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line614"></a>614           when :last  then find_last(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line615"></a>615           when :all   then find_every(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line616"></a>616           else             find_from_ids(args, options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line617"></a>617         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line618"></a>618       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line619"></a>619 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line620"></a>620       # A convenience wrapper for <tt>find(:first, *args)</tt>. You can pass in all the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line621"></a>621       # same arguments to this method as you can to <tt>find(:first)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line622"></a>622       def first(*args)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line623"></a>623         find(:first, *args)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line624"></a>624       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line625"></a>625 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line626"></a>626       # A convenience wrapper for <tt>find(:last, *args)</tt>. You can pass in all the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line627"></a>627       # same arguments to this method as you can to <tt>find(:last)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line628"></a>628       def last(*args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line629"></a>629         find(:last, *args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line630"></a>630       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line631"></a>631 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line632"></a>632       # This is an alias for find(:all).  You can pass in all the same arguments to this method as you can</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line633"></a>633       # to find(:all)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line634"></a>634       def all(*args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line635"></a>635         find(:all, *args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line636"></a>636       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line637"></a>637 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line638"></a>638       # Executes a custom SQL query against your database and returns all the results.  The results will</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line639"></a>639       # be returned as an array with columns requested encapsulated as attributes of the model you call</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line640"></a>640       # this method from.  If you call <tt>Product.find_by_sql</tt> then the results will be returned in</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line641"></a>641       # a Product object with the attributes you specified in the SQL query.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line642"></a>642       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line643"></a>643       # If you call a complicated SQL query which spans multiple tables the columns specified by the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line644"></a>644       # SELECT will be attributes of the model, whether or not they are columns of the corresponding</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line645"></a>645       # table.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line646"></a>646       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line647"></a>647       # The +sql+ parameter is a full SQL query as a string.  It will be called as is, there will be</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line648"></a>648       # no database agnostic conversions performed.  This should be a last resort because using, for example,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line649"></a>649       # MySQL specific terms will lock you to using that particular database engine or require you to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line650"></a>650       # change your call if you switch engines.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line651"></a>651       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line652"></a>652       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line653"></a>653       #   # A simple SQL query spanning multiple tables</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line654"></a>654       #   Post.find_by_sql "SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line655"></a>655       #   > [#<Post:0x36bff9c @attributes={"title"=>"Ruby Meetup", "first_name"=>"Quentin"}>, ...]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line656"></a>656       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line657"></a>657       #   # You can use the same string replacement techniques as you can with ActiveRecord#find</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line658"></a>658       #   Post.find_by_sql ["SELECT title FROM posts WHERE author = ? AND created > ?", author_id, start_date]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line659"></a>659       #   > [#<Post:0x36bff9c @attributes={"first_name"=>"The Cheap Man Buys Twice"}>, ...]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line660"></a>660       def find_by_sql(sql)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line661"></a>661         connection.select_all(sanitize_sql(sql), "#{name} Load").collect! { |record| instantiate(record) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line662"></a>662       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line663"></a>663 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line664"></a>664       # Returns true if a record exists in the table that matches the +id+ or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line665"></a>665       # conditions given, or false otherwise. The argument can take five forms:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line666"></a>666       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line667"></a>667       # * Integer - Finds the record with this primary key.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line668"></a>668       # * String - Finds the record with a primary key corresponding to this</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line669"></a>669       #   string (such as <tt>'5'</tt>).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line670"></a>670       # * Array - Finds the record that matches these +find+-style conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line671"></a>671       #   (such as <tt>['color = ?', 'red']</tt>).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line672"></a>672       # * Hash - Finds the record that matches these +find+-style conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line673"></a>673       #   (such as <tt>{:color => 'red'}</tt>).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line674"></a>674       # * No args - Returns false if the table is empty, true otherwise.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line675"></a>675       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line676"></a>676       # For more information about specifying conditions as a Hash or Array,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line677"></a>677       # see the Conditions section in the introduction to ActiveRecord::Base.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line678"></a>678       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line679"></a>679       # Note: You can't pass in a condition as a string (like <tt>name =</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line680"></a>680       # 'Jamie'</tt>), since it would be sanitized and then queried against</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line681"></a>681       # the primary key column, like <tt>id = 'name = \'Jamie\''</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line682"></a>682       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line683"></a>683       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line684"></a>684       #   Person.exists?(5)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line685"></a>685       #   Person.exists?('5')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line686"></a>686       #   Person.exists?(:name => "David")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line687"></a>687       #   Person.exists?(['name LIKE ?', "%#{query}%"])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line688"></a>688       #   Person.exists?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line689"></a>689       def exists?(id_or_conditions = {})</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line690"></a>690         find_initial(</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line691"></a>691           :select => "#{quoted_table_name}.#{primary_key}",</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line692"></a>692           :conditions => expand_id_conditions(id_or_conditions)) ? true : false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line693"></a>693       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line694"></a>694 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line695"></a>695       # Creates an object (or multiple objects) and saves it to the database, if validations pass.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line696"></a>696       # The resulting object is returned whether the object was saved successfully to the database or not.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line697"></a>697       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line698"></a>698       # The +attributes+ parameter can be either be a Hash or an Array of Hashes.  These Hashes describe the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line699"></a>699       # attributes on the objects that are to be created.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line700"></a>700       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line701"></a>701       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line702"></a>702       #   # Create a single new object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line703"></a>703       #   User.create(:first_name => 'Jamie')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line704"></a>704       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line705"></a>705       #   # Create an Array of new objects</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line706"></a>706       #   User.create([{ :first_name => 'Jamie' }, { :first_name => 'Jeremy' }])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line707"></a>707       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line708"></a>708       #   # Create a single object and pass it into a block to set other attributes.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line709"></a>709       #   User.create(:first_name => 'Jamie') do |u|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line710"></a>710       #     u.is_admin = false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line711"></a>711       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line712"></a>712       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line713"></a>713       #   # Creating an Array of new objects using a block, where the block is executed for each object:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line714"></a>714       #   User.create([{ :first_name => 'Jamie' }, { :first_name => 'Jeremy' }]) do |u|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line715"></a>715       #     u.is_admin = false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line716"></a>716       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line717"></a>717       def create(attributes = nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line718"></a>718         if attributes.is_a?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line719"></a>719           attributes.collect { |attr| create(attr, &block) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line720"></a>720         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line721"></a>721           object = new(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line722"></a>722           yield(object) if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line723"></a>723           object.save</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line724"></a>724           object</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line725"></a>725         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line726"></a>726       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line727"></a>727 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line728"></a>728       # Updates an object (or multiple objects) and saves it to the database, if validations pass.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line729"></a>729       # The resulting object is returned whether the object was saved successfully to the database or not.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line730"></a>730       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line731"></a>731       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line732"></a>732       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line733"></a>733       # * +id+ - This should be the id or an array of ids to be updated.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line734"></a>734       # * +attributes+ - This should be a hash of attributes to be set on the object, or an array of hashes.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line735"></a>735       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line736"></a>736       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line737"></a>737       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line738"></a>738       #   # Updating one record:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line739"></a>739       #   Person.update(15, :user_name => 'Samuel', :group => 'expert')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line740"></a>740       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line741"></a>741       #   # Updating multiple records:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line742"></a>742       #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line743"></a>743       #   Person.update(people.keys, people.values)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line744"></a>744       def update(id, attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line745"></a>745         if id.is_a?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line746"></a>746           idx = -1</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line747"></a>747           id.collect { |one_id| idx += 1; update(one_id, attributes[idx]) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line748"></a>748         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line749"></a>749           object = find(id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line750"></a>750           object.update_attributes(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line751"></a>751           object</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line752"></a>752         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line753"></a>753       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line754"></a>754 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line755"></a>755       # Deletes the row with a primary key matching the +id+ argument, using a</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line756"></a>756       # SQL +DELETE+ statement, and returns the number of rows deleted. Active</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line757"></a>757       # Record objects are not instantiated, so the object's callbacks are not</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line758"></a>758       # executed, including any <tt>:dependent</tt> association options or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line759"></a>759       # Observer methods.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line760"></a>760       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line761"></a>761       # You can delete multiple rows at once by passing an Array of <tt>id</tt>s.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line762"></a>762       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line763"></a>763       # Note: Although it is often much faster than the alternative,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line764"></a>764       # <tt>#destroy</tt>, skipping callbacks might bypass business logic in</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line765"></a>765       # your application that ensures referential integrity or performs other</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line766"></a>766       # essential jobs.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line767"></a>767       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line768"></a>768       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line769"></a>769       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line770"></a>770       #   # Delete a single row</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line771"></a>771       #   Todo.delete(1)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line772"></a>772       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line773"></a>773       #   # Delete multiple rows</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line774"></a>774       #   Todo.delete([2,3,4])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line775"></a>775       def delete(id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line776"></a>776         delete_all([ "#{connection.quote_column_name(primary_key)} IN (?)", id ])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line777"></a>777       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line778"></a>778 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line779"></a>779       # Destroy an object (or multiple objects) that has the given id, the object is instantiated first,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line780"></a>780       # therefore all callbacks and filters are fired off before the object is deleted.  This method is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line781"></a>781       # less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line782"></a>782       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line783"></a>783       # This essentially finds the object (or multiple objects) with the given id, creates a new object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line784"></a>784       # from the attributes, and then calls destroy on it.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line785"></a>785       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line786"></a>786       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line787"></a>787       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line788"></a>788       # * +id+ - Can be either an Integer or an Array of Integers.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line789"></a>789       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line790"></a>790       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line791"></a>791       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line792"></a>792       #   # Destroy a single object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line793"></a>793       #   Todo.destroy(1)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line794"></a>794       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line795"></a>795       #   # Destroy multiple objects</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line796"></a>796       #   todos = [1,2,3]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line797"></a>797       #   Todo.destroy(todos)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line798"></a>798       def destroy(id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line799"></a>799         if id.is_a?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line800"></a>800           id.map { |one_id| destroy(one_id) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line801"></a>801         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line802"></a>802           find(id).destroy</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line803"></a>803         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line804"></a>804       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line805"></a>805 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line806"></a>806       # Updates all records with details given if they match a set of conditions supplied, limits and order can</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line807"></a>807       # also be supplied. This method constructs a single SQL UPDATE statement and sends it straight to the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line808"></a>808       # database. It does not instantiate the involved models and it does not trigger Active Record callbacks.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line809"></a>809       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line810"></a>810       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line811"></a>811       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line812"></a>812       # * +updates+ - A string of column and value pairs that will be set on any records that match conditions. This creates the SET clause of the generated SQL.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line813"></a>813       # * +conditions+ - An SQL fragment like "administrator = 1" or [ "user_name = ?", username ]. See conditions in the intro for more info.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line814"></a>814       # * +options+ - Additional options are <tt>:limit</tt> and <tt>:order</tt>, see the examples for usage.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line815"></a>815       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line816"></a>816       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line817"></a>817       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line818"></a>818       #   # Update all billing objects with the 3 different attributes given</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line819"></a>819       #   Billing.update_all( "category = 'authorized', approved = 1, author = 'David'" )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line820"></a>820       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line821"></a>821       #   # Update records that match our conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line822"></a>822       #   Billing.update_all( "author = 'David'", "title LIKE '%Rails%'" )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line823"></a>823       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line824"></a>824       #   # Update records that match our conditions but limit it to 5 ordered by date</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line825"></a>825       #   Billing.update_all( "author = 'David'", "title LIKE '%Rails%'",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line826"></a>826       #                         :order => 'created_at', :limit => 5 )</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line827"></a>827       def update_all(updates, conditions = nil, options = {})</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line828"></a>828         sql  = "UPDATE #{quoted_table_name} SET #{sanitize_sql_for_assignment(updates)} "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line829"></a>829 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line830"></a>830         scope = scope(:find)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line831"></a>831 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line832"></a>832         select_sql = ""</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line833"></a>833         add_conditions!(select_sql, conditions, scope)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line834"></a>834 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line835"></a>835         if options.has_key?(:limit) || (scope && scope[:limit])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line836"></a>836           # Only take order from scope if limit is also provided by scope, this</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line837"></a>837           # is useful for updating a has_many association with a limit.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line838"></a>838           add_order!(select_sql, options[:order], scope)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line839"></a>839 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line840"></a>840           add_limit!(select_sql, options, scope)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line841"></a>841           sql.concat(connection.limited_update_conditions(select_sql, quoted_table_name, connection.quote_column_name(primary_key)))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line842"></a>842         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line843"></a>843           add_order!(select_sql, options[:order], nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line844"></a>844           sql.concat(select_sql)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line845"></a>845         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line846"></a>846 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line847"></a>847         connection.update(sql, "#{name} Update")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line848"></a>848       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line849"></a>849 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line850"></a>850       # Destroys the records matching +conditions+ by instantiating each</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line851"></a>851       # record and calling its +destroy+ method. Each object's callbacks are</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line852"></a>852       # executed (including <tt>:dependent</tt> association options and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line853"></a>853       # +before_destroy+/+after_destroy+ Observer methods). Returns the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line854"></a>854       # collection of objects that were destroyed; each will be frozen, to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line855"></a>855       # reflect that no changes should be made (since they can't be</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line856"></a>856       # persisted).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line857"></a>857       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line858"></a>858       # Note: Instantiation, callback execution, and deletion of each</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line859"></a>859       # record can be time consuming when you're removing many records at</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line860"></a>860       # once. It generates at least one SQL +DELETE+ query per record (or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line861"></a>861       # possibly more, to enforce your callbacks). If you want to delete many</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line862"></a>862       # rows quickly, without concern for their associations or callbacks, use</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line863"></a>863       # +delete_all+ instead.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line864"></a>864       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line865"></a>865       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line866"></a>866       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line867"></a>867       # * +conditions+ - A string, array, or hash that specifies which records</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line868"></a>868       #   to destroy. If omitted, all records are destroyed. See the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line869"></a>869       #   Conditions section in the introduction to ActiveRecord::Base for</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line870"></a>870       #   more information.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line871"></a>871       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line872"></a>872       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line873"></a>873       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line874"></a>874       #   Person.destroy_all("last_login < '2004-04-04'")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line875"></a>875       #   Person.destroy_all(:status => "inactive")</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line876"></a>876       def destroy_all(conditions = nil)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line877"></a>877         find(:all, :conditions => conditions).each { |object| object.destroy }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line878"></a>878       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line879"></a>879 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line880"></a>880       # Deletes the records matching +conditions+ without instantiating the records first, and hence not</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line881"></a>881       # calling the +destroy+ method nor invoking callbacks. This is a single SQL DELETE statement that</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line882"></a>882       # goes straight to the database, much more efficient than +destroy_all+. Be careful with relations</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line883"></a>883       # though, in particular <tt>:dependent</tt> rules defined on associations are not honored.  Returns</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line884"></a>884       # the number of rows affected.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line885"></a>885       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line886"></a>886       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line887"></a>887       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line888"></a>888       # * +conditions+ - Conditions are specified the same way as with +find+ method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line889"></a>889       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line890"></a>890       # ==== Example</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line891"></a>891       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line892"></a>892       #   Post.delete_all("person_id = 5 AND (category = 'Something' OR category = 'Else')")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line893"></a>893       #   Post.delete_all(["person_id = ? AND (category = ? OR category = ?)", 5, 'Something', 'Else'])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line894"></a>894       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line895"></a>895       # Both calls delete the affected posts all at once with a single DELETE statement. If you need to destroy dependent</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line896"></a>896       # associations or call your <tt>before_*</tt> or +after_destroy+ callbacks, use the +destroy_all+ method instead.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line897"></a>897       def delete_all(conditions = nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line898"></a>898         sql = "DELETE FROM #{quoted_table_name} "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line899"></a>899         add_conditions!(sql, conditions, scope(:find))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line900"></a>900         connection.delete(sql, "#{name} Delete all")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line901"></a>901       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line902"></a>902 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line903"></a>903       # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line904"></a>904       # The use of this method should be restricted to complicated SQL queries that can't be executed</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line905"></a>905       # using the ActiveRecord::Calculations class methods.  Look into those before using this.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line906"></a>906       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line907"></a>907       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line908"></a>908       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line909"></a>909       # * +sql+ - An SQL statement which should return a count query from the database, see the example below.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line910"></a>910       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line911"></a>911       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line912"></a>912       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line913"></a>913       #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line914"></a>914       def count_by_sql(sql)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line915"></a>915         sql = sanitize_conditions(sql)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line916"></a>916         connection.select_value(sql, "#{name} Count").to_i</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line917"></a>917       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line918"></a>918 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line919"></a>919       # A generic "counter updater" implementation, intended primarily to be</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line920"></a>920       # used by increment_counter and decrement_counter, but which may also</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line921"></a>921       # be useful on its own. It simply does a direct SQL update for the record</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line922"></a>922       # with the given ID, altering the given hash of counters by the amount</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line923"></a>923       # given by the corresponding value:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line924"></a>924       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line925"></a>925       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line926"></a>926       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line927"></a>927       # * +id+ - The id of the object you wish to update a counter on or an Array of ids.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line928"></a>928       # * +counters+ - An Array of Hashes containing the names of the fields</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line929"></a>929       #   to update as keys and the amount to update the field by as values.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line930"></a>930       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line931"></a>931       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line932"></a>932       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line933"></a>933       #   # For the Post with id of 5, decrement the comment_count by 1, and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line934"></a>934       #   # increment the action_count by 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line935"></a>935       #   Post.update_counters 5, :comment_count => -1, :action_count => 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line936"></a>936       #   # Executes the following SQL:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line937"></a>937       #   # UPDATE posts</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line938"></a>938       #   #    SET comment_count = comment_count - 1,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line939"></a>939       #   #        action_count = action_count + 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line940"></a>940       #   #  WHERE id = 5</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line941"></a>941       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line942"></a>942       #   # For the Posts with id of 10 and 15, increment the comment_count by 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line943"></a>943       #   Post.update_counters [10, 15], :comment_count => 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line944"></a>944       #   # Executes the following SQL:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line945"></a>945       #   # UPDATE posts</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line946"></a>946       #   #    SET comment_count = comment_count + 1,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line947"></a>947       #   #  WHERE id IN (10, 15)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line948"></a>948       def update_counters(id, counters)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line949"></a>949         updates = counters.inject([]) { |list, (counter_name, increment)|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line950"></a>950           sign = increment < 0 ? "-" : "+"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line951"></a>951           list << "#{connection.quote_column_name(counter_name)} = COALESCE(#{connection.quote_column_name(counter_name)}, 0) #{sign} #{increment.abs}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line952"></a>952         }.join(", ")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line953"></a>953 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line954"></a>954         if id.is_a?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line955"></a>955           ids_list = id.map {|i| quote_value(i)}.join(', ')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line956"></a>956           condition = "IN  (#{ids_list})"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line957"></a>957         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line958"></a>958           condition = "= #{quote_value(id)}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line959"></a>959         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line960"></a>960 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line961"></a>961         update_all(updates, "#{connection.quote_column_name(primary_key)} #{condition}")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line962"></a>962       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line963"></a>963 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line964"></a>964       # Increment a number field by one, usually representing a count.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line965"></a>965       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line966"></a>966       # This is used for caching aggregate values, so that they don't need to be computed every time.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line967"></a>967       # For example, a DiscussionBoard may cache post_count and comment_count otherwise every time the board is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line968"></a>968       # shown it would have to run an SQL query to find how many posts and comments there are.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line969"></a>969       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line970"></a>970       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line971"></a>971       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line972"></a>972       # * +counter_name+ - The name of the field that should be incremented.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line973"></a>973       # * +id+ - The id of the object that should be incremented.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line974"></a>974       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line975"></a>975       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line976"></a>976       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line977"></a>977       #   # Increment the post_count column for the record with an id of 5</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line978"></a>978       #   DiscussionBoard.increment_counter(:post_count, 5)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line979"></a>979       def increment_counter(counter_name, id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line980"></a>980         update_counters(id, counter_name => 1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line981"></a>981       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line982"></a>982 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line983"></a>983       # Decrement a number field by one, usually representing a count.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line984"></a>984       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line985"></a>985       # This works the same as increment_counter but reduces the column value by 1 instead of increasing it.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line986"></a>986       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line987"></a>987       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line988"></a>988       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line989"></a>989       # * +counter_name+ - The name of the field that should be decremented.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line990"></a>990       # * +id+ - The id of the object that should be decremented.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line991"></a>991       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line992"></a>992       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line993"></a>993       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line994"></a>994       #   # Decrement the post_count column for the record with an id of 5</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line995"></a>995       #   DiscussionBoard.decrement_counter(:post_count, 5)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line996"></a>996       def decrement_counter(counter_name, id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line997"></a>997         update_counters(id, counter_name => -1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line998"></a>998       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line999"></a>999 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1000"></a>1000       # Attributes named in this macro are protected from mass-assignment,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1001"></a>1001       # such as <tt>new(attributes)</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1002"></a>1002       # <tt>update_attributes(attributes)</tt>, or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1003"></a>1003       # <tt>attributes=(attributes)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1004"></a>1004       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1005"></a>1005       # Mass-assignment to these attributes will simply be ignored, to assign</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1006"></a>1006       # to them you can use direct writer methods. This is meant to protect</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1007"></a>1007       # sensitive attributes from being overwritten by malicious users</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1008"></a>1008       # tampering with URLs or forms.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1009"></a>1009       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1010"></a>1010       #   class Customer < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1011"></a>1011       #     attr_protected :credit_rating</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1012"></a>1012       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1013"></a>1013       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1014"></a>1014       #   customer = Customer.new("name" => David, "credit_rating" => "Excellent")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1015"></a>1015       #   customer.credit_rating # => nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1016"></a>1016       #   customer.attributes = { "description" => "Jolly fellow", "credit_rating" => "Superb" }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1017"></a>1017       #   customer.credit_rating # => nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1018"></a>1018       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1019"></a>1019       #   customer.credit_rating = "Average"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1020"></a>1020       #   customer.credit_rating # => "Average"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1021"></a>1021       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1022"></a>1022       # To start from an all-closed default and enable attributes as needed,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1023"></a>1023       # have a look at +attr_accessible+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1024"></a>1024       def attr_protected(*attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1025"></a>1025         write_inheritable_attribute(:attr_protected, Set.new(attributes.map(&:to_s)) + (protected_attributes || []))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1026"></a>1026       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1027"></a>1027 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1028"></a>1028       # Returns an array of all the attributes that have been protected from mass-assignment.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1029"></a>1029       def protected_attributes # :nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1030"></a>1030         read_inheritable_attribute(:attr_protected)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1031"></a>1031       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1032"></a>1032 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1033"></a>1033       # Specifies a white list of model attributes that can be set via</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1034"></a>1034       # mass-assignment, such as <tt>new(attributes)</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1035"></a>1035       # <tt>update_attributes(attributes)</tt>, or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1036"></a>1036       # <tt>attributes=(attributes)</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1037"></a>1037       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1038"></a>1038       # This is the opposite of the +attr_protected+ macro: Mass-assignment</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1039"></a>1039       # will only set attributes in this list, to assign to the rest of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1040"></a>1040       # attributes you can use direct writer methods. This is meant to protect</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1041"></a>1041       # sensitive attributes from being overwritten by malicious users</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1042"></a>1042       # tampering with URLs or forms. If you'd rather start from an all-open</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1043"></a>1043       # default and restrict attributes as needed, have a look at</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1044"></a>1044       # +attr_protected+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1045"></a>1045       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1046"></a>1046       #   class Customer < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1047"></a>1047       #     attr_accessible :name, :nickname</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1048"></a>1048       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1049"></a>1049       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1050"></a>1050       #   customer = Customer.new(:name => "David", :nickname => "Dave", :credit_rating => "Excellent")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1051"></a>1051       #   customer.credit_rating # => nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1052"></a>1052       #   customer.attributes = { :name => "Jolly fellow", :credit_rating => "Superb" }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1053"></a>1053       #   customer.credit_rating # => nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1054"></a>1054       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1055"></a>1055       #   customer.credit_rating = "Average"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1056"></a>1056       #   customer.credit_rating # => "Average"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1057"></a>1057       def attr_accessible(*attributes)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1058"></a>1058         write_inheritable_attribute(:attr_accessible, Set.new(attributes.map(&:to_s)) + (accessible_attributes || []))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1059"></a>1059       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1060"></a>1060 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1061"></a>1061       # Returns an array of all the attributes that have been made accessible to mass-assignment.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1062"></a>1062       def accessible_attributes # :nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1063"></a>1063         read_inheritable_attribute(:attr_accessible)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1064"></a>1064       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1065"></a>1065 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1066"></a>1066        # Attributes listed as readonly can be set for a new record, but will be ignored in database updates afterwards.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1067"></a>1067        def attr_readonly(*attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1068"></a>1068          write_inheritable_attribute(:attr_readonly, Set.new(attributes.map(&:to_s)) + (readonly_attributes || []))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1069"></a>1069        end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1070"></a>1070 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1071"></a>1071        # Returns an array of all the attributes that have been specified as readonly.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1072"></a>1072        def readonly_attributes</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1073"></a>1073          read_inheritable_attribute(:attr_readonly)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1074"></a>1074        end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1075"></a>1075 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1076"></a>1076       # If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1077"></a>1077       # then specify the name of that attribute using this method and it will be handled automatically.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1078"></a>1078       # The serialization is done through YAML. If +class_name+ is specified, the serialized object must be of that</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1079"></a>1079       # class on retrieval or SerializationTypeMismatch will be raised.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1080"></a>1080       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1081"></a>1081       # ==== Parameters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1082"></a>1082       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1083"></a>1083       # * +attr_name+ - The field name that should be serialized.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1084"></a>1084       # * +class_name+ - Optional, class name that the object type should be equal to.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1085"></a>1085       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1086"></a>1086       # ==== Example</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1087"></a>1087       #   # Serialize a preferences attribute</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1088"></a>1088       #   class User</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1089"></a>1089       #     serialize :preferences</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1090"></a>1090       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1091"></a>1091       def serialize(attr_name, class_name = Object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1092"></a>1092         serialized_attributes[attr_name.to_s] = class_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1093"></a>1093       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1094"></a>1094 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1095"></a>1095       # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1096"></a>1096       def serialized_attributes</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1097"></a>1097         read_inheritable_attribute(:attr_serialized) or write_inheritable_attribute(:attr_serialized, {})</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1098"></a>1098       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1099"></a>1099 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1100"></a>1100       # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1101"></a>1101       # directly from ActiveRecord::Base. So if the hierarchy looks like: Reply < Message < ActiveRecord::Base, then Message is used</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1102"></a>1102       # to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1103"></a>1103       # in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1104"></a>1104       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1105"></a>1105       # Nested classes are given table names prefixed by the singular form of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1106"></a>1106       # the parent's table name. Enclosing modules are not considered.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1107"></a>1107       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1108"></a>1108       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1109"></a>1109       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1110"></a>1110       #   class Invoice < ActiveRecord::Base; end;</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1111"></a>1111       #   file                  class               table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1112"></a>1112       #   invoice.rb            Invoice             invoices</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1113"></a>1113       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1114"></a>1114       #   class Invoice < ActiveRecord::Base; class Lineitem < ActiveRecord::Base; end; end;</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1115"></a>1115       #   file                  class               table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1116"></a>1116       #   invoice.rb            Invoice::Lineitem   invoice_lineitems</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1117"></a>1117       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1118"></a>1118       #   module Invoice; class Lineitem < ActiveRecord::Base; end; end;</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1119"></a>1119       #   file                  class               table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1120"></a>1120       #   invoice/lineitem.rb   Invoice::Lineitem   lineitems</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1121"></a>1121       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1122"></a>1122       # Additionally, the class-level +table_name_prefix+ is prepended and the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1123"></a>1123       # +table_name_suffix+ is appended.  So if you have "myapp_" as a prefix,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1124"></a>1124       # the table name guess for an Invoice class becomes "myapp_invoices".</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1125"></a>1125       # Invoice::Lineitem becomes "myapp_invoice_lineitems".</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1126"></a>1126       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1127"></a>1127       # You can also overwrite this class method to allow for unguessable</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1128"></a>1128       # links, such as a Mouse class with a link to a "mice" table. Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1129"></a>1129       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1130"></a>1130       #   class Mouse < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1131"></a>1131       #     set_table_name "mice"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1132"></a>1132       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1133"></a>1133       def table_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1134"></a>1134         reset_table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1135"></a>1135       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1136"></a>1136 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1137"></a>1137       def reset_table_name #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1138"></a>1138         base = base_class</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1139"></a>1139 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1140"></a>1140         name =</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1141"></a>1141           # STI subclasses always use their superclass' table.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1142"></a>1142           unless self == base</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1143"></a>1143             base.table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1144"></a>1144           else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1145"></a>1145             # Nested classes are prefixed with singular parent table name.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1146"></a>1146             if parent < ActiveRecord::Base && !parent.abstract_class?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1147"></a>1147               contained = parent.table_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1148"></a>1148               contained = contained.singularize if parent.pluralize_table_names</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1149"></a>1149               contained << '_'</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1150"></a>1150             end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1151"></a>1151             name = "#{table_name_prefix}#{contained}#{undecorated_table_name(base.name)}#{table_name_suffix}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1152"></a>1152           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1153"></a>1153 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1154"></a>1154         set_table_name(name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1155"></a>1155         name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1156"></a>1156       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1157"></a>1157 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1158"></a>1158       # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1159"></a>1159       # primary_key_prefix_type setting, though.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1160"></a>1160       def primary_key</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1161"></a>1161         reset_primary_key</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1162"></a>1162       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1163"></a>1163 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1164"></a>1164       def reset_primary_key #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1165"></a>1165         key = get_primary_key(base_class.name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1166"></a>1166         set_primary_key(key)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1167"></a>1167         key</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1168"></a>1168       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1169"></a>1169 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1170"></a>1170       def get_primary_key(base_name) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1171"></a>1171         key = 'id'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1172"></a>1172         case primary_key_prefix_type</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1173"></a>1173           when :table_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1174"></a>1174             key = base_name.to_s.foreign_key(false)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1175"></a>1175           when :table_name_with_underscore</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1176"></a>1176             key = base_name.to_s.foreign_key</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1177"></a>1177         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1178"></a>1178         key</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1179"></a>1179       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1180"></a>1180 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1181"></a>1181       # Defines the column name for use with single table inheritance</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1182"></a>1182       # -- can be set in subclasses like so: self.inheritance_column = "type_id"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1183"></a>1183       def inheritance_column</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1184"></a>1184         @inheritance_column ||= "type".freeze</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1185"></a>1185       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1186"></a>1186 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1187"></a>1187       # Lazy-set the sequence name to the connection's default.  This method</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1188"></a>1188       # is only ever called once since set_sequence_name overrides it.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1189"></a>1189       def sequence_name #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1190"></a>1190         reset_sequence_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1191"></a>1191       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1192"></a>1192 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1193"></a>1193       def reset_sequence_name #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1194"></a>1194         default = connection.default_sequence_name(table_name, primary_key)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1195"></a>1195         set_sequence_name(default)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1196"></a>1196         default</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1197"></a>1197       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1198"></a>1198 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1199"></a>1199       # Sets the table name to use to the given value, or (if the value</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1200"></a>1200       # is nil or false) to the value returned by the given block.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1201"></a>1201       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1202"></a>1202       #   class Project < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1203"></a>1203       #     set_table_name "project"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1204"></a>1204       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1205"></a>1205       def set_table_name(value = nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1206"></a>1206         define_attr_method :table_name, value, &block</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1207"></a>1207       end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1208"></a>1208       alias :table_name= :set_table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1209"></a>1209 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1210"></a>1210       # Sets the name of the primary key column to use to the given value,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1211"></a>1211       # or (if the value is nil or false) to the value returned by the given</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1212"></a>1212       # block.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1213"></a>1213       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1214"></a>1214       #   class Project < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1215"></a>1215       #     set_primary_key "sysid"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1216"></a>1216       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1217"></a>1217       def set_primary_key(value = nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1218"></a>1218         define_attr_method :primary_key, value, &block</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1219"></a>1219       end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1220"></a>1220       alias :primary_key= :set_primary_key</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1221"></a>1221 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1222"></a>1222       # Sets the name of the inheritance column to use to the given value,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1223"></a>1223       # or (if the value # is nil or false) to the value returned by the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1224"></a>1224       # given block.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1225"></a>1225       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1226"></a>1226       #   class Project < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1227"></a>1227       #     set_inheritance_column do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1228"></a>1228       #       original_inheritance_column + "_id"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1229"></a>1229       #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1230"></a>1230       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1231"></a>1231       def set_inheritance_column(value = nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1232"></a>1232         define_attr_method :inheritance_column, value, &block</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1233"></a>1233       end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1234"></a>1234       alias :inheritance_column= :set_inheritance_column</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1235"></a>1235 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1236"></a>1236       # Sets the name of the sequence to use when generating ids to the given</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1237"></a>1237       # value, or (if the value is nil or false) to the value returned by the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1238"></a>1238       # given block. This is required for Oracle and is useful for any</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1239"></a>1239       # database which relies on sequences for primary key generation.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1240"></a>1240       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1241"></a>1241       # If a sequence name is not explicitly set when using Oracle or Firebird,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1242"></a>1242       # it will default to the commonly used pattern of: #{table_name}_seq</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1243"></a>1243       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1244"></a>1244       # If a sequence name is not explicitly set when using PostgreSQL, it</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1245"></a>1245       # will discover the sequence corresponding to your primary key for you.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1246"></a>1246       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1247"></a>1247       #   class Project < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1248"></a>1248       #     set_sequence_name "projectseq"   # default would have been "project_seq"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1249"></a>1249       #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1250"></a>1250       def set_sequence_name(value = nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1251"></a>1251         define_attr_method :sequence_name, value, &block</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1252"></a>1252       end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1253"></a>1253       alias :sequence_name= :set_sequence_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1254"></a>1254 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1255"></a>1255       # Turns the +table_name+ back into a class name following the reverse rules of +table_name+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1256"></a>1256       def class_name(table_name = table_name) # :nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1257"></a>1257         # remove any prefix and/or suffix from the table name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1258"></a>1258         class_name = table_name[table_name_prefix.length..-(table_name_suffix.length + 1)].camelize</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1259"></a>1259         class_name = class_name.singularize if pluralize_table_names</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1260"></a>1260         class_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1261"></a>1261       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1262"></a>1262 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1263"></a>1263       # Indicates whether the table associated with this class exists</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1264"></a>1264       def table_exists?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1265"></a>1265         connection.table_exists?(table_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1266"></a>1266       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1267"></a>1267 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1268"></a>1268       # Returns an array of column objects for the table associated with this class.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1269"></a>1269       def columns</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1270"></a>1270         unless defined?(@columns) && @columns</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1271"></a>1271           @columns = connection.columns(table_name, "#{name} Columns")</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1272"></a>1272           @columns.each { |column| column.primary = column.name == primary_key }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1273"></a>1273         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1274"></a>1274         @columns</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1275"></a>1275       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1276"></a>1276 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1277"></a>1277       # Returns a hash of column objects for the table associated with this class.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1278"></a>1278       def columns_hash</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1279"></a>1279         @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1280"></a>1280       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1281"></a>1281 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1282"></a>1282       # Returns an array of column names as strings.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1283"></a>1283       def column_names</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1284"></a>1284         @column_names ||= columns.map { |column| column.name }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1285"></a>1285       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1286"></a>1286 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1287"></a>1287       # Returns an array of column objects where the primary id, all columns ending in "_id" or "_count",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1288"></a>1288       # and columns used for single table inheritance have been removed.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1289"></a>1289       def content_columns</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1290"></a>1290         @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1291"></a>1291       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1292"></a>1292 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1293"></a>1293       # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1294"></a>1294       # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1295"></a>1295       # is available.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1296"></a>1296       def column_methods_hash #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1297"></a>1297         @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1298"></a>1298           attr_name = attr.to_s</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1299"></a>1299           methods[attr.to_sym]       = attr_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1300"></a>1300           methods["#{attr}=".to_sym] = attr_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1301"></a>1301           methods["#{attr}?".to_sym] = attr_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1302"></a>1302           methods["#{attr}_before_type_cast".to_sym] = attr_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1303"></a>1303           methods</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1304"></a>1304         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1305"></a>1305       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1306"></a>1306 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1307"></a>1307       # Resets all the cached information about columns, which will cause them</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1308"></a>1308       # to be reloaded on the next request.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1309"></a>1309       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1310"></a>1310       # The most common usage pattern for this method is probably in a migration,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1311"></a>1311       # when just after creating a table you want to populate it with some default</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1312"></a>1312       # values, eg:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1313"></a>1313       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1314"></a>1314       #  class CreateJobLevels < ActiveRecord::Migration</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1315"></a>1315       #    def self.up</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1316"></a>1316       #      create_table :job_levels do |t|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1317"></a>1317       #        t.integer :id</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1318"></a>1318       #        t.string :name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1319"></a>1319       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1320"></a>1320       #        t.timestamps</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1321"></a>1321       #      end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1322"></a>1322       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1323"></a>1323       #      JobLevel.reset_column_information</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1324"></a>1324       #      %w{assistant executive manager director}.each do |type|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1325"></a>1325       #        JobLevel.create(:name => type)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1326"></a>1326       #      end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1327"></a>1327       #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1328"></a>1328       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1329"></a>1329       #    def self.down</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1330"></a>1330       #      drop_table :job_levels</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1331"></a>1331       #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1332"></a>1332       #  end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1333"></a>1333       def reset_column_information</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1334"></a>1334         generated_methods.each { |name| undef_method(name) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1335"></a>1335         @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @generated_methods = @inheritance_column = nil</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1336"></a>1336       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1337"></a>1337 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1338"></a>1338       def reset_column_information_and_inheritable_attributes_for_all_subclasses#:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1339"></a>1339         subclasses.each { |klass| klass.reset_inheritable_attributes; klass.reset_column_information }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1340"></a>1340       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1341"></a>1341 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1342"></a>1342       def self_and_descendants_from_active_record#nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1343"></a>1343         klass = self</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1344"></a>1344         classes = [klass]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1345"></a>1345         while klass != klass.base_class  </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1346"></a>1346           classes << klass = klass.superclass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1347"></a>1347         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1348"></a>1348         classes</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1349"></a>1349       rescue</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1350"></a>1350         # OPTIMIZE this rescue is to fix this test: ./test/cases/reflection_test.rb:56:in `test_human_name_for_column'</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1351"></a>1351         # Appearantly the method base_class causes some trouble.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1352"></a>1352         # It now works for sure.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1353"></a>1353         [self]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1354"></a>1354       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1355"></a>1355 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1356"></a>1356       # Transforms attribute key names into a more humane format, such as "First name" instead of "first_name". Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1357"></a>1357       #   Person.human_attribute_name("first_name") # => "First name"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1358"></a>1358       # This used to be depricated in favor of humanize, but is now preferred, because it automatically uses the I18n</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1359"></a>1359       # module now.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1360"></a>1360       # Specify +options+ with additional translating options.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1361"></a>1361       def human_attribute_name(attribute_key_name, options = {})</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1362"></a>1362         defaults = self_and_descendants_from_active_record.map do |klass|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1363"></a>1363           :"#{klass.name.underscore}.#{attribute_key_name}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1364"></a>1364         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1365"></a>1365         defaults << options[:default] if options[:default]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1366"></a>1366         defaults.flatten!</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1367"></a>1367         defaults << attribute_key_name.to_s.humanize</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1368"></a>1368         options[:count] ||= 1</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1369"></a>1369         I18n.translate(defaults.shift, options.merge(:default => defaults, :scope => [:activerecord, :attributes]))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1370"></a>1370       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1371"></a>1371 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1372"></a>1372       # Transform the modelname into a more humane format, using I18n.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1373"></a>1373       # Defaults to the basic humanize method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1374"></a>1374       # Default scope of the translation is activerecord.models</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1375"></a>1375       # Specify +options+ with additional translating options.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1376"></a>1376       def human_name(options = {})</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1377"></a>1377         defaults = self_and_descendants_from_active_record.map do |klass|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1378"></a>1378           :"#{klass.name.underscore}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1379"></a>1379         end </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1380"></a>1380         defaults << self.name.humanize</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1381"></a>1381         I18n.translate(defaults.shift, {:scope => [:activerecord, :models], :count => 1, :default => defaults}.merge(options))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1382"></a>1382       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1383"></a>1383 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1384"></a>1384       # True if this isn't a concrete subclass needing a STI type condition.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1385"></a>1385       def descends_from_active_record?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1386"></a>1386         if superclass.abstract_class?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1387"></a>1387           superclass.descends_from_active_record?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1388"></a>1388         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1389"></a>1389           superclass == Base || !columns_hash.include?(inheritance_column)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1390"></a>1390         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1391"></a>1391       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1392"></a>1392 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1393"></a>1393       def finder_needs_type_condition? #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1394"></a>1394         # This is like this because benchmarking justifies the strange :false stuff</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1395"></a>1395         :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1396"></a>1396       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1397"></a>1397 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1398"></a>1398       # Returns a string like 'Post id:integer, title:string, body:text'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1399"></a>1399       def inspect</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1400"></a>1400         if self == Base</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1401"></a>1401           super</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1402"></a>1402         elsif abstract_class?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1403"></a>1403           "#{super}(abstract)"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1404"></a>1404         elsif table_exists?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1405"></a>1405           attr_list = columns.map { |c| "#{c.name}: #{c.type}" } * ', '</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1406"></a>1406           "#{super}(#{attr_list})"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1407"></a>1407         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1408"></a>1408           "#{super}(Table doesn't exist)"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1409"></a>1409         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1410"></a>1410       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1411"></a>1411 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1412"></a>1412       def quote_value(value, column = nil) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1413"></a>1413         connection.quote(value,column)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1414"></a>1414       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1415"></a>1415 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1416"></a>1416       # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to <tt>connection.quote</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1417"></a>1417       def sanitize(object) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1418"></a>1418         connection.quote(object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1419"></a>1419       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1420"></a>1420 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1421"></a>1421       # Log and benchmark multiple statements in a single block. Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1422"></a>1422       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1423"></a>1423       #   Project.benchmark("Creating project") do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1424"></a>1424       #     project = Project.create("name" => "stuff")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1425"></a>1425       #     project.create_manager("name" => "David")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1426"></a>1426       #     project.milestones << Milestone.find(:all)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1427"></a>1427       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1428"></a>1428       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1429"></a>1429       # The benchmark is only recorded if the current level of the logger is less than or equal to the <tt>log_level</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1430"></a>1430       # which makes it easy to include benchmarking statements in production software that will remain inexpensive because</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1431"></a>1431       # the benchmark will only be conducted if the log level is low enough.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1432"></a>1432       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1433"></a>1433       # The logging of the multiple statements is turned off unless <tt>use_silence</tt> is set to false.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1434"></a>1434       def benchmark(title, log_level = Logger::DEBUG, use_silence = true)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1435"></a>1435         if logger && logger.level <= log_level</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1436"></a>1436           result = nil</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1437"></a>1437           ms = Benchmark.ms { result = use_silence ? silence { yield } : yield }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1438"></a>1438           logger.add(log_level, '%s (%.1fms)' % [title, ms])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1439"></a>1439           result</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1440"></a>1440         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1441"></a>1441           yield</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1442"></a>1442         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1443"></a>1443       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1444"></a>1444 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1445"></a>1445       # Silences the logger for the duration of the block.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1446"></a>1446       def silence</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1447"></a>1447         old_logger_level, logger.level = logger.level, Logger::ERROR if logger</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1448"></a>1448         yield</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1449"></a>1449       ensure</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1450"></a>1450         logger.level = old_logger_level if logger</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1451"></a>1451       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1452"></a>1452 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1453"></a>1453       # Overwrite the default class equality method to provide support for association proxies.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1454"></a>1454       def ===(object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1455"></a>1455         object.is_a?(self)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1456"></a>1456       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1457"></a>1457 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1458"></a>1458       # Returns the base AR subclass that this class descends from. If A</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1459"></a>1459       # extends AR::Base, A.base_class will return A. If B descends from A</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1460"></a>1460       # through some arbitrarily deep hierarchy, B.base_class will return A.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1461"></a>1461       def base_class</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1462"></a>1462         class_of_active_record_descendant(self)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1463"></a>1463       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1464"></a>1464 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1465"></a>1465       # Set this to true if this is an abstract class (see <tt>abstract_class?</tt>).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1466"></a>1466       attr_accessor :abstract_class</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1467"></a>1467 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1468"></a>1468       # Returns whether this class is a base AR class.  If A is a base class and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1469"></a>1469       # B descends from A, then B.base_class will return B.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1470"></a>1470       def abstract_class?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1471"></a>1471         defined?(@abstract_class) && @abstract_class == true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1472"></a>1472       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1473"></a>1473 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1474"></a>1474       def respond_to?(method_id, include_private = false)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1475"></a>1475         if match = DynamicFinderMatch.match(method_id)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1476"></a>1476           return true if all_attributes_exists?(match.attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1477"></a>1477         elsif match = DynamicScopeMatch.match(method_id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1478"></a>1478           return true if all_attributes_exists?(match.attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1479"></a>1479         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1480"></a>1480 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1481"></a>1481         super</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1482"></a>1482       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1483"></a>1483 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1484"></a>1484       def sti_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1485"></a>1485         store_full_sti_class ? name : name.demodulize</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1486"></a>1486       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1487"></a>1487 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1488"></a>1488       # Merges conditions so that the result is a valid +condition+</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1489"></a>1489       def merge_conditions(*conditions)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1490"></a>1490         segments = []</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1491"></a>1491 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1492"></a>1492         conditions.each do |condition|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1493"></a>1493           unless condition.blank?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1494"></a>1494             sql = sanitize_sql(condition)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1495"></a>1495             segments << sql unless sql.blank?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1496"></a>1496           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1497"></a>1497         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1498"></a>1498 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1499"></a>1499         "(#{segments.join(') AND (')})" unless segments.empty?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1500"></a>1500       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1501"></a>1501 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1502"></a>1502       private</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1503"></a>1503         def find_initial(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1504"></a>1504           options.update(:limit => 1)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1505"></a>1505           find_every(options).first</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1506"></a>1506         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1507"></a>1507 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1508"></a>1508         def find_last(options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1509"></a>1509           order = options[:order]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1510"></a>1510 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1511"></a>1511           if order</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1512"></a>1512             order = reverse_sql_order(order)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1513"></a>1513           elsif !scoped?(:find, :order)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1514"></a>1514             order = "#{table_name}.#{primary_key} DESC"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1515"></a>1515           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1516"></a>1516 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1517"></a>1517           if scoped?(:find, :order)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1518"></a>1518             scope = scope(:find)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1519"></a>1519             original_scoped_order = scope[:order]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1520"></a>1520             scope[:order] = reverse_sql_order(original_scoped_order)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1521"></a>1521           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1522"></a>1522 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1523"></a>1523           begin</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1524"></a>1524             find_initial(options.merge({ :order => order }))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1525"></a>1525           ensure</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1526"></a>1526             scope[:order] = original_scoped_order if original_scoped_order</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1527"></a>1527           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1528"></a>1528         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1529"></a>1529 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1530"></a>1530         def reverse_sql_order(order_query)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1531"></a>1531           reversed_query = order_query.to_s.split(/,/).each { |s|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1532"></a>1532             if s.match(/\s(asc|ASC)$/)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1533"></a>1533               s.gsub!(/\s(asc|ASC)$/, ' DESC')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1534"></a>1534             elsif s.match(/\s(desc|DESC)$/)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1535"></a>1535               s.gsub!(/\s(desc|DESC)$/, ' ASC')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1536"></a>1536             elsif !s.match(/\s(asc|ASC|desc|DESC)$/)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1537"></a>1537               s.concat(' DESC')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1538"></a>1538             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1539"></a>1539           }.join(',')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1540"></a>1540         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1541"></a>1541 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1542"></a>1542         def find_every(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1543"></a>1543           include_associations = merge_includes(scope(:find, :include), options[:include])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1544"></a>1544 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1545"></a>1545           if include_associations.any? && references_eager_loaded_tables?(options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1546"></a>1546             records = find_with_associations(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1547"></a>1547           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1548"></a>1548             records = find_by_sql(construct_finder_sql(options))</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1549"></a>1549             if include_associations.any?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1550"></a>1550               preload_associations(records, include_associations)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1551"></a>1551             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1552"></a>1552           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1553"></a>1553 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1554"></a>1554           records.each { |record| record.readonly! } if options[:readonly]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1555"></a>1555 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1556"></a>1556           records</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1557"></a>1557         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1558"></a>1558 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1559"></a>1559         def find_from_ids(ids, options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1560"></a>1560           expects_array = ids.first.kind_of?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1561"></a>1561           return ids.first if expects_array && ids.first.empty?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1562"></a>1562 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1563"></a>1563           ids = ids.flatten.compact.uniq</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1564"></a>1564 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1565"></a>1565           case ids.size</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1566"></a>1566             when 0</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1567"></a>1567               raise RecordNotFound, "Couldn't find #{name} without an ID"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1568"></a>1568             when 1</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1569"></a>1569               result = find_one(ids.first, options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1570"></a>1570               expects_array ? [ result ] : result</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1571"></a>1571             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1572"></a>1572               find_some(ids, options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1573"></a>1573           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1574"></a>1574         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1575"></a>1575 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1576"></a>1576         def find_one(id, options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1577"></a>1577           conditions = " AND (#{sanitize_sql(options[:conditions])})" if options[:conditions]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1578"></a>1578           options.update :conditions => "#{quoted_table_name}.#{connection.quote_column_name(primary_key)} = #{quote_value(id,columns_hash[primary_key])}#{conditions}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1579"></a>1579 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1580"></a>1580           # Use find_every(options).first since the primary key condition</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1581"></a>1581           # already ensures we have a single record. Using find_initial adds</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1582"></a>1582           # a superfluous :limit => 1.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1583"></a>1583           if result = find_every(options).first</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1584"></a>1584             result</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1585"></a>1585           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1586"></a>1586             raise RecordNotFound, "Couldn't find #{name} with ID=#{id}#{conditions}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1587"></a>1587           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1588"></a>1588         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1589"></a>1589 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1590"></a>1590         def find_some(ids, options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1591"></a>1591           conditions = " AND (#{sanitize_sql(options[:conditions])})" if options[:conditions]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1592"></a>1592           ids_list   = ids.map { |id| quote_value(id,columns_hash[primary_key]) }.join(',')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1593"></a>1593           options.update :conditions => "#{quoted_table_name}.#{connection.quote_column_name(primary_key)} IN (#{ids_list})#{conditions}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1594"></a>1594 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1595"></a>1595           result = find_every(options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1596"></a>1596 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1597"></a>1597           # Determine expected size from limit and offset, not just ids.size.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1598"></a>1598           expected_size =</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1599"></a>1599             if options[:limit] && ids.size > options[:limit]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1600"></a>1600               options[:limit]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1601"></a>1601             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1602"></a>1602               ids.size</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1603"></a>1603             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1604"></a>1604 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1605"></a>1605           # 11 ids with limit 3, offset 9 should give 2 results.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1606"></a>1606           if options[:offset] && (ids.size - options[:offset] < expected_size)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1607"></a>1607             expected_size = ids.size - options[:offset]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1608"></a>1608           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1609"></a>1609 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1610"></a>1610           if result.size == expected_size</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1611"></a>1611             result</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1612"></a>1612           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1613"></a>1613             raise RecordNotFound, "Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions} (found #{result.size} results, but was looking for #{expected_size})"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1614"></a>1614           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1615"></a>1615         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1616"></a>1616 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1617"></a>1617         # Finder methods must instantiate through this method to work with the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1618"></a>1618         # single-table inheritance model that makes it possible to create</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1619"></a>1619         # objects of different types from the same table.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1620"></a>1620         def instantiate(record)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1621"></a>1621           object =</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1622"></a>1622             if subclass_name = record[inheritance_column]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1623"></a>1623               # No type given.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1624"></a>1624               if subclass_name.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1625"></a>1625                 allocate</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1626"></a>1626 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1627"></a>1627               else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1628"></a>1628                 # Ignore type if no column is present since it was probably</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1629"></a>1629                 # pulled in from a sloppy join.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1630"></a>1630                 unless columns_hash.include?(inheritance_column)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1631"></a>1631                   allocate</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1632"></a>1632 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1633"></a>1633                 else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1634"></a>1634                   begin</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1635"></a>1635                     compute_type(subclass_name).allocate</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1636"></a>1636                   rescue NameError</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1637"></a>1637                     raise SubclassNotFound,</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1638"></a>1638                       "The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. " +</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1639"></a>1639                       "This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. " +</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1640"></a>1640                       "Please rename this column if you didn't intend it to be used for storing the inheritance class " +</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1641"></a>1641                       "or overwrite #{self.to_s}.inheritance_column to use another column for that information."</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1642"></a>1642                   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1643"></a>1643                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1644"></a>1644               end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1645"></a>1645             else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1646"></a>1646               allocate</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1647"></a>1647             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1648"></a>1648 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1649"></a>1649           object.instance_variable_set("@attributes", record)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1650"></a>1650           object.instance_variable_set("@attributes_cache", Hash.new)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1651"></a>1651 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1652"></a>1652           if object.respond_to_without_attributes?(:after_find)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1653"></a>1653             object.send(:callback, :after_find)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1654"></a>1654           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1655"></a>1655 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1656"></a>1656           if object.respond_to_without_attributes?(:after_initialize)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1657"></a>1657             object.send(:callback, :after_initialize)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1658"></a>1658           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1659"></a>1659 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1660"></a>1660           object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1661"></a>1661         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1662"></a>1662 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1663"></a>1663         # Nest the type name in the same module as this class.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1664"></a>1664         # Bar is "MyApp::Business::Bar" relative to MyApp::Business::Foo</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1665"></a>1665         def type_name_with_module(type_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1666"></a>1666           if store_full_sti_class</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1667"></a>1667             type_name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1668"></a>1668           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1669"></a>1669             (/^::/ =~ type_name) ? type_name : "#{parent.name}::#{type_name}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1670"></a>1670           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1671"></a>1671         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1672"></a>1672 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1673"></a>1673         def default_select(qualified)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1674"></a>1674           if qualified</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1675"></a>1675             quoted_table_name + '.*'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1676"></a>1676           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1677"></a>1677             '*'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1678"></a>1678           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1679"></a>1679         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1680"></a>1680 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1681"></a>1681         def construct_finder_sql(options)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1682"></a>1682           scope = scope(:find)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1683"></a>1683           sql  = "SELECT #{options[:select] || (scope && scope[:select]) || default_select(options[:joins] || (scope && scope[:joins]))} "</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1684"></a>1684           sql << "FROM #{options[:from]  || (scope && scope[:from]) || quoted_table_name} "</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1685"></a>1685 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1686"></a>1686           add_joins!(sql, options[:joins], scope)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1687"></a>1687           add_conditions!(sql, options[:conditions], scope)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1688"></a>1688 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1689"></a>1689           add_group!(sql, options[:group], options[:having], scope)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1690"></a>1690           add_order!(sql, options[:order], scope)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1691"></a>1691           add_limit!(sql, options, scope)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1692"></a>1692           add_lock!(sql, options, scope)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1693"></a>1693 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1694"></a>1694           sql</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1695"></a>1695         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1696"></a>1696 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1697"></a>1697         # Merges includes so that the result is a valid +include+</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1698"></a>1698         def merge_includes(first, second)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1699"></a>1699          (safe_to_array(first) + safe_to_array(second)).uniq</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1700"></a>1700         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1701"></a>1701 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1702"></a>1702         def merge_joins(*joins)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1703"></a>1703           if joins.any?{|j| j.is_a?(String) || array_of_strings?(j) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1704"></a>1704             joins = joins.collect do |join|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1705"></a>1705               join = [join] if join.is_a?(String)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1706"></a>1706               unless array_of_strings?(join)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1707"></a>1707                 join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, join, nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1708"></a>1708                 join = join_dependency.join_associations.collect { |assoc| assoc.association_join }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1709"></a>1709               end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1710"></a>1710               join</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1711"></a>1711             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1712"></a>1712             joins.flatten.map{|j| j.strip}.uniq</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1713"></a>1713           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1714"></a>1714             joins.collect{|j| safe_to_array(j)}.flatten.uniq</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1715"></a>1715           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1716"></a>1716         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1717"></a>1717 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1718"></a>1718         # Object#to_a is deprecated, though it does have the desired behavior</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1719"></a>1719         def safe_to_array(o)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1720"></a>1720           case o</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1721"></a>1721           when NilClass</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1722"></a>1722             []</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1723"></a>1723           when Array</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1724"></a>1724             o</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1725"></a>1725           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1726"></a>1726             [o]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1727"></a>1727           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1728"></a>1728         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1729"></a>1729 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1730"></a>1730         def array_of_strings?(o)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1731"></a>1731           o.is_a?(Array) && o.all?{|obj| obj.is_a?(String)}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1732"></a>1732         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1733"></a>1733 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1734"></a>1734         def add_order!(sql, order, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1735"></a>1735           scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1736"></a>1736           scoped_order = scope[:order] if scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1737"></a>1737           if order</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1738"></a>1738             sql << " ORDER BY #{order}"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1739"></a>1739             if scoped_order && scoped_order != order</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1740"></a>1740               sql << ", #{scoped_order}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1741"></a>1741             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1742"></a>1742           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1743"></a>1743             sql << " ORDER BY #{scoped_order}" if scoped_order</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1744"></a>1744           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1745"></a>1745         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1746"></a>1746 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1747"></a>1747         def add_group!(sql, group, having, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1748"></a>1748           if group</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1749"></a>1749             sql << " GROUP BY #{group}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1750"></a>1750             sql << " HAVING #{sanitize_sql_for_conditions(having)}" if having</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1751"></a>1751           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1752"></a>1752             scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1753"></a>1753             if scope && (scoped_group = scope[:group])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1754"></a>1754               sql << " GROUP BY #{scoped_group}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1755"></a>1755               sql << " HAVING #{sanitize_sql_for_conditions(scope[:having])}" if scope[:having]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1756"></a>1756             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1757"></a>1757           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1758"></a>1758         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1759"></a>1759 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1760"></a>1760         # The optional scope argument is for the current <tt>:find</tt> scope.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1761"></a>1761         def add_limit!(sql, options, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1762"></a>1762           scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1763"></a>1763 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1764"></a>1764           if scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1765"></a>1765             options[:limit] ||= scope[:limit]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1766"></a>1766             options[:offset] ||= scope[:offset]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1767"></a>1767           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1768"></a>1768 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1769"></a>1769           connection.add_limit_offset!(sql, options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1770"></a>1770         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1771"></a>1771 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1772"></a>1772         # The optional scope argument is for the current <tt>:find</tt> scope.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1773"></a>1773         # The <tt>:lock</tt> option has precedence over a scoped <tt>:lock</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1774"></a>1774         def add_lock!(sql, options, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1775"></a>1775           scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1776"></a>1776           options = options.reverse_merge(:lock => scope[:lock]) if scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1777"></a>1777           connection.add_lock!(sql, options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1778"></a>1778         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1779"></a>1779 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1780"></a>1780         # The optional scope argument is for the current <tt>:find</tt> scope.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1781"></a>1781         def add_joins!(sql, joins, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1782"></a>1782           scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1783"></a>1783           merged_joins = scope && scope[:joins] && joins ? merge_joins(scope[:joins], joins) : (joins || scope && scope[:joins])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1784"></a>1784           case merged_joins</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1785"></a>1785           when Symbol, Hash, Array</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1786"></a>1786             if array_of_strings?(merged_joins)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1787"></a>1787               sql << merged_joins.join(' ') + " "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1788"></a>1788             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1789"></a>1789               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, merged_joins, nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1790"></a>1790               sql << " #{join_dependency.join_associations.collect { |assoc| assoc.association_join }.join} "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1791"></a>1791             end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1792"></a>1792           when String</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1793"></a>1793             sql << " #{merged_joins} "</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1794"></a>1794           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1795"></a>1795         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1796"></a>1796 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1797"></a>1797         # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1798"></a>1798         # The optional scope argument is for the current <tt>:find</tt> scope.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1799"></a>1799         def add_conditions!(sql, conditions, scope = :auto)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1800"></a>1800           scope = scope(:find) if :auto == scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1801"></a>1801           conditions = [conditions]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1802"></a>1802           conditions << scope[:conditions] if scope</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1803"></a>1803           conditions << type_condition if finder_needs_type_condition?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1804"></a>1804           merged_conditions = merge_conditions(*conditions)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1805"></a>1805           sql << "WHERE #{merged_conditions} " unless merged_conditions.blank?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1806"></a>1806         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1807"></a>1807 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1808"></a>1808         def type_condition(table_alias=nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1809"></a>1809           quoted_table_alias = self.connection.quote_table_name(table_alias || table_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1810"></a>1810           quoted_inheritance_column = connection.quote_column_name(inheritance_column)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1811"></a>1811           type_condition = subclasses.inject("#{quoted_table_alias}.#{quoted_inheritance_column} = '#{sti_name}' ") do |condition, subclass|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1812"></a>1812             condition << "OR #{quoted_table_alias}.#{quoted_inheritance_column} = '#{subclass.sti_name}' "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1813"></a>1813           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1814"></a>1814 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1815"></a>1815           " (#{type_condition}) "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1816"></a>1816         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1817"></a>1817 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1818"></a>1818         # Guesses the table name, but does not decorate it with prefix and suffix information.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1819"></a>1819         def undecorated_table_name(class_name = base_class.name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1820"></a>1820           table_name = class_name.to_s.demodulize.underscore</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1821"></a>1821           table_name = table_name.pluralize if pluralize_table_names</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1822"></a>1822           table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1823"></a>1823         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1824"></a>1824 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1825"></a>1825         # Enables dynamic finders like <tt>find_by_user_name(user_name)</tt> and <tt>find_by_user_name_and_password(user_name, password)</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1826"></a>1826         # that are turned into <tt>find(:first, :conditions => ["user_name = ?", user_name])</tt> and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1827"></a>1827         # <tt>find(:first, :conditions => ["user_name = ? AND password = ?", user_name, password])</tt> respectively. Also works for</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1828"></a>1828         # <tt>find(:all)</tt> by using <tt>find_all_by_amount(50)</tt> that is turned into <tt>find(:all, :conditions => ["amount = ?", 50])</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1829"></a>1829         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1830"></a>1830         # It's even possible to use all the additional parameters to +find+. For example, the full interface for +find_all_by_amount+</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1831"></a>1831         # is actually <tt>find_all_by_amount(amount, options)</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1832"></a>1832         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1833"></a>1833         # Also enables dynamic scopes like scoped_by_user_name(user_name) and scoped_by_user_name_and_password(user_name, password) that</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1834"></a>1834         # are turned into scoped(:conditions => ["user_name = ?", user_name]) and scoped(:conditions => ["user_name = ? AND password = ?", user_name, password])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1835"></a>1835         # respectively.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1836"></a>1836         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1837"></a>1837         # Each dynamic finder, scope or initializer/creator is also defined in the class after it is first invoked, so that future</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1838"></a>1838         # attempts to use it do not run through method_missing.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1839"></a>1839         def method_missing(method_id, *arguments, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1840"></a>1840           if match = DynamicFinderMatch.match(method_id)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1841"></a>1841             attribute_names = match.attribute_names</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1842"></a>1842             super unless all_attributes_exists?(attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1843"></a>1843             if match.finder?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1844"></a>1844               finder = match.finder</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1845"></a>1845               bang = match.bang?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1846"></a>1846               # def self.find_by_login_and_activated(*args)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1847"></a>1847               #   options = args.extract_options!</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1848"></a>1848               #   attributes = construct_attributes_from_arguments(</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1849"></a>1849               #     [:login,:activated],</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1850"></a>1850               #     args</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1851"></a>1851               #   )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1852"></a>1852               #   finder_options = { :conditions => attributes }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1853"></a>1853               #   validate_find_options(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1854"></a>1854               #   set_readonly_option!(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1855"></a>1855               #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1856"></a>1856               #   if options[:conditions]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1857"></a>1857               #     with_scope(:find => finder_options) do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1858"></a>1858               #       find(:first, options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1859"></a>1859               #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1860"></a>1860               #   else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1861"></a>1861               #     find(:first, options.merge(finder_options))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1862"></a>1862               #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1863"></a>1863               # end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1864"></a>1864               self.class_eval %{</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1865"></a>1865                 def self.#{method_id}(*args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1866"></a>1866                   options = args.extract_options!</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1867"></a>1867                   attributes = construct_attributes_from_arguments(</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1868"></a>1868                     [:#{attribute_names.join(',:')}],</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1869"></a>1869                     args</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1870"></a>1870                   )</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1871"></a>1871                   finder_options = { :conditions => attributes }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1872"></a>1872                   validate_find_options(options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1873"></a>1873                   set_readonly_option!(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1874"></a>1874 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1875"></a>1875                   #{'result = ' if bang}if options[:conditions]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1876"></a>1876                     with_scope(:find => finder_options) do</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1877"></a>1877                       find(:#{finder}, options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1878"></a>1878                     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1879"></a>1879                   else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1880"></a>1880                     find(:#{finder}, options.merge(finder_options))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1881"></a>1881                   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1882"></a>1882                   #{'result || raise(RecordNotFound, "Couldn\'t find #{name} with #{attributes.to_a.collect {|pair| "#{pair.first} = #{pair.second}"}.join(\', \')}")' if bang}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1883"></a>1883                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1884"></a>1884               }, __FILE__, __LINE__</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1885"></a>1885               send(method_id, *arguments)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1886"></a>1886             elsif match.instantiator?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1887"></a>1887               instantiator = match.instantiator</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1888"></a>1888               # def self.find_or_create_by_user_id(*args)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1889"></a>1889               #   guard_protected_attributes = false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1890"></a>1890               #</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1891"></a>1891               #   if args[0].is_a?(Hash)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1892"></a>1892               #     guard_protected_attributes = true</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1893"></a>1893               #     attributes = args[0].with_indifferent_access</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1894"></a>1894               #     find_attributes = attributes.slice(*[:user_id])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1895"></a>1895               #   else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1896"></a>1896               #     find_attributes = attributes = construct_attributes_from_arguments([:user_id], args)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1897"></a>1897               #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1898"></a>1898               #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1899"></a>1899               #   options = { :conditions => find_attributes }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1900"></a>1900               #   set_readonly_option!(options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1901"></a>1901               #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1902"></a>1902               #   record = find(:first, options)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1903"></a>1903               #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1904"></a>1904               #   if record.nil?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1905"></a>1905               #     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1906"></a>1906               #     yield(record) if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1907"></a>1907               #     record.save</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1908"></a>1908               #     record</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1909"></a>1909               #   else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1910"></a>1910               #     record</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1911"></a>1911               #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1912"></a>1912               # end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1913"></a>1913               self.class_eval %{</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1914"></a>1914                 def self.#{method_id}(*args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1915"></a>1915                   guard_protected_attributes = false</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1916"></a>1916 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1917"></a>1917                   if args[0].is_a?(Hash)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1918"></a>1918                     guard_protected_attributes = true</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1919"></a>1919                     attributes = args[0].with_indifferent_access</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1920"></a>1920                     find_attributes = attributes.slice(*[:#{attribute_names.join(',:')}])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1921"></a>1921                   else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1922"></a>1922                     find_attributes = attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1923"></a>1923                   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1924"></a>1924 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1925"></a>1925                   options = { :conditions => find_attributes }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1926"></a>1926                   set_readonly_option!(options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1927"></a>1927 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1928"></a>1928                   record = find(:first, options)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1929"></a>1929 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1930"></a>1930                   if record.nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1931"></a>1931                     record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1932"></a>1932                     #{'yield(record) if block_given?'}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1933"></a>1933                     #{'record.save' if instantiator == :create}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1934"></a>1934                     record</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1935"></a>1935                   else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1936"></a>1936                     record</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1937"></a>1937                   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1938"></a>1938                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1939"></a>1939               }, __FILE__, __LINE__</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1940"></a>1940               send(method_id, *arguments, &block)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1941"></a>1941             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1942"></a>1942           elsif match = DynamicScopeMatch.match(method_id)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1943"></a>1943             attribute_names = match.attribute_names</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1944"></a>1944             super unless all_attributes_exists?(attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1945"></a>1945             if match.scope?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1946"></a>1946               self.class_eval %{</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1947"></a>1947                 def self.#{method_id}(*args)                        # def self.scoped_by_user_name_and_password(*args)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1948"></a>1948                   options = args.extract_options!                   #   options = args.extract_options!</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1949"></a>1949                   attributes = construct_attributes_from_arguments( #   attributes = construct_attributes_from_arguments(</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1950"></a>1950                     [:#{attribute_names.join(',:')}], args          #     [:user_name, :password], args</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1951"></a>1951                   )                                                 #   )</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1952"></a>1952                                                                     # </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1953"></a>1953                   scoped(:conditions => attributes)                 #   scoped(:conditions => attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1954"></a>1954                 end                                                 # end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1955"></a>1955               }, __FILE__, __LINE__</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1956"></a>1956               send(method_id, *arguments)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1957"></a>1957             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1958"></a>1958           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1959"></a>1959             super</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1960"></a>1960           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1961"></a>1961         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1962"></a>1962 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1963"></a>1963         def construct_attributes_from_arguments(attribute_names, arguments)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1964"></a>1964           attributes = {}</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1965"></a>1965           attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1966"></a>1966           attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1967"></a>1967         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1968"></a>1968 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1969"></a>1969         # Similar in purpose to +expand_hash_conditions_for_aggregates+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1970"></a>1970         def expand_attribute_names_for_aggregates(attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1971"></a>1971           expanded_attribute_names = []</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1972"></a>1972           attribute_names.each do |attribute_name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1973"></a>1973             unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1974"></a>1974               aggregate_mapping(aggregation).each do |field_attr, aggregate_attr|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1975"></a>1975                 expanded_attribute_names << field_attr</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1976"></a>1976               end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1977"></a>1977             else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1978"></a>1978               expanded_attribute_names << attribute_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1979"></a>1979             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1980"></a>1980           end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1981"></a>1981           expanded_attribute_names</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1982"></a>1982         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1983"></a>1983 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1984"></a>1984         def all_attributes_exists?(attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1985"></a>1985           attribute_names = expand_attribute_names_for_aggregates(attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1986"></a>1986           attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1987"></a>1987         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1988"></a>1988 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1989"></a>1989         def attribute_condition(quoted_column_name, argument)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1990"></a>1990           case argument</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1991"></a>1991             when nil   then "#{quoted_column_name} IS ?"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1992"></a>1992             when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then "#{quoted_column_name} IN (?)"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1993"></a>1993             when Range then if argument.exclude_end?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1994"></a>1994                               "#{quoted_column_name} >= ? AND #{quoted_column_name} < ?"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1995"></a>1995                             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1996"></a>1996                               "#{quoted_column_name} BETWEEN ? AND ?"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line1997"></a>1997                             end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1998"></a>1998             else            "#{quoted_column_name} = ?"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1999"></a>1999           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2000"></a>2000         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2001"></a>2001 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2002"></a>2002         # Interpret Array and Hash as conditions and anything else as an id.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2003"></a>2003         def expand_id_conditions(id_or_conditions)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2004"></a>2004           case id_or_conditions</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2005"></a>2005             when Array, Hash then id_or_conditions</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2006"></a>2006             else sanitize_sql(primary_key => id_or_conditions)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2007"></a>2007           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2008"></a>2008         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2009"></a>2009 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2010"></a>2010         # Defines an "attribute" method (like +inheritance_column+ or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2011"></a>2011         # +table_name+). A new (class) method will be created with the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2012"></a>2012         # given name. If a value is specified, the new method will</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2013"></a>2013         # return that value (as a string). Otherwise, the given block</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2014"></a>2014         # will be used to compute the value of the method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2015"></a>2015         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2016"></a>2016         # The original method will be aliased, with the new name being</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2017"></a>2017         # prefixed with "original_". This allows the new method to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2018"></a>2018         # access the original value.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2019"></a>2019         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2020"></a>2020         # Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2021"></a>2021         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2022"></a>2022         #   class A < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2023"></a>2023         #     define_attr_method :primary_key, "sysid"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2024"></a>2024         #     define_attr_method( :inheritance_column ) do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2025"></a>2025         #       original_inheritance_column + "_id"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2026"></a>2026         #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2027"></a>2027         #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2028"></a>2028         def define_attr_method(name, value=nil, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2029"></a>2029           sing = class << self; self; end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2030"></a>2030           sing.send :alias_method, "original_#{name}", name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2031"></a>2031           if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2032"></a>2032             sing.send :define_method, name, &block</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2033"></a>2033           else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2034"></a>2034             # use eval instead of a block to work around a memory leak in dev</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2035"></a>2035             # mode in fcgi</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2036"></a>2036             sing.class_eval "def #{name}; #{value.to_s.inspect}; end"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2037"></a>2037           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2038"></a>2038         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2039"></a>2039 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2040"></a>2040       protected</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2041"></a>2041         # Scope parameters to method calls within the block.  Takes a hash of method_name => parameters hash.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2042"></a>2042         # method_name may be <tt>:find</tt> or <tt>:create</tt>. <tt>:find</tt> parameters may include the <tt>:conditions</tt>, <tt>:joins</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2043"></a>2043         # <tt>:include</tt>, <tt>:offset</tt>, <tt>:limit</tt>, and <tt>:readonly</tt> options. <tt>:create</tt> parameters are an attributes hash.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2044"></a>2044         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2045"></a>2045         #   class Article < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2046"></a>2046         #     def self.create_with_scope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2047"></a>2047         #       with_scope(:find => { :conditions => "blog_id = 1" }, :create => { :blog_id => 1 }) do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2048"></a>2048         #         find(1) # => SELECT * from articles WHERE blog_id = 1 AND id = 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2049"></a>2049         #         a = create(1)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2050"></a>2050         #         a.blog_id # => 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2051"></a>2051         #       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2052"></a>2052         #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2053"></a>2053         #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2054"></a>2054         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2055"></a>2055         # In nested scopings, all previous parameters are overwritten by the innermost rule, with the exception of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2056"></a>2056         # <tt>:conditions</tt>, <tt>:include</tt>, and <tt>:joins</tt> options in <tt>:find</tt>, which are merged.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2057"></a>2057         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2058"></a>2058         # <tt>:joins</tt> options are uniqued so multiple scopes can join in the same table without table aliasing</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2059"></a>2059         # problems.  If you need to join multiple tables, but still want one of the tables to be uniqued, use the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2060"></a>2060         # array of strings format for your joins.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2061"></a>2061         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2062"></a>2062         #   class Article < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2063"></a>2063         #     def self.find_with_scope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2064"></a>2064         #       with_scope(:find => { :conditions => "blog_id = 1", :limit => 1 }, :create => { :blog_id => 1 }) do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2065"></a>2065         #         with_scope(:find => { :limit => 10 })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2066"></a>2066         #           find(:all) # => SELECT * from articles WHERE blog_id = 1 LIMIT 10</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2067"></a>2067         #         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2068"></a>2068         #         with_scope(:find => { :conditions => "author_id = 3" })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2069"></a>2069         #           find(:all) # => SELECT * from articles WHERE blog_id = 1 AND author_id = 3 LIMIT 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2070"></a>2070         #         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2071"></a>2071         #       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2072"></a>2072         #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2073"></a>2073         #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2074"></a>2074         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2075"></a>2075         # You can ignore any previous scopings by using the <tt>with_exclusive_scope</tt> method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2076"></a>2076         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2077"></a>2077         #   class Article < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2078"></a>2078         #     def self.find_with_exclusive_scope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2079"></a>2079         #       with_scope(:find => { :conditions => "blog_id = 1", :limit => 1 }) do</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2080"></a>2080         #         with_exclusive_scope(:find => { :limit => 10 })</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2081"></a>2081         #           find(:all) # => SELECT * from articles LIMIT 10</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2082"></a>2082         #         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2083"></a>2083         #       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2084"></a>2084         #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2085"></a>2085         #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2086"></a>2086         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2087"></a>2087         # *Note*: the +:find+ scope also has effect on update and deletion methods,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2088"></a>2088         # like +update_all+ and +delete_all+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2089"></a>2089         def with_scope(method_scoping = {}, action = :merge, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2090"></a>2090           method_scoping = method_scoping.method_scoping if method_scoping.respond_to?(:method_scoping)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2091"></a>2091 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2092"></a>2092           # Dup first and second level of hash (method and params).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2093"></a>2093           method_scoping = method_scoping.inject({}) do |hash, (method, params)|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2094"></a>2094             hash[method] = (params == true) ? params : params.dup</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2095"></a>2095             hash</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2096"></a>2096           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2097"></a>2097 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2098"></a>2098           method_scoping.assert_valid_keys([ :find, :create ])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2099"></a>2099 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2100"></a>2100           if f = method_scoping[:find]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2101"></a>2101             f.assert_valid_keys(VALID_FIND_OPTIONS)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2102"></a>2102             set_readonly_option! f</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2103"></a>2103           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2104"></a>2104 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2105"></a>2105           # Merge scopings</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2106"></a>2106           if [:merge, :reverse_merge].include?(action) && current_scoped_methods</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2107"></a>2107             method_scoping = current_scoped_methods.inject(method_scoping) do |hash, (method, params)|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2108"></a>2108               case hash[method]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2109"></a>2109                 when Hash</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2110"></a>2110                   if method == :find</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2111"></a>2111                     (hash[method].keys + params.keys).uniq.each do |key|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2112"></a>2112                       merge = hash[method][key] && params[key] # merge if both scopes have the same key</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2113"></a>2113                       if key == :conditions && merge</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2114"></a>2114                         if params[key].is_a?(Hash) && hash[method][key].is_a?(Hash)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2115"></a>2115                           hash[method][key] = merge_conditions(hash[method][key].deep_merge(params[key]))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2116"></a>2116                         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2117"></a>2117                           hash[method][key] = merge_conditions(params[key], hash[method][key])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2118"></a>2118                         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2119"></a>2119                       elsif key == :include && merge</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2120"></a>2120                         hash[method][key] = merge_includes(hash[method][key], params[key]).uniq</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2121"></a>2121                       elsif key == :joins && merge</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2122"></a>2122                         hash[method][key] = merge_joins(params[key], hash[method][key])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2123"></a>2123                       else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2124"></a>2124                         hash[method][key] = hash[method][key] || params[key]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2125"></a>2125                       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2126"></a>2126                     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2127"></a>2127                   else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2128"></a>2128                     if action == :reverse_merge</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2129"></a>2129                       hash[method] = hash[method].merge(params)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2130"></a>2130                     else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2131"></a>2131                       hash[method] = params.merge(hash[method])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2132"></a>2132                     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2133"></a>2133                   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2134"></a>2134                 else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2135"></a>2135                   hash[method] = params</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2136"></a>2136               end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2137"></a>2137               hash</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2138"></a>2138             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2139"></a>2139           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2140"></a>2140 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2141"></a>2141           self.scoped_methods << method_scoping</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2142"></a>2142           begin</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2143"></a>2143             yield</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2144"></a>2144           ensure</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2145"></a>2145             self.scoped_methods.pop</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2146"></a>2146           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2147"></a>2147         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2148"></a>2148 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2149"></a>2149         # Works like with_scope, but discards any nested properties.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2150"></a>2150         def with_exclusive_scope(method_scoping = {}, &block)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2151"></a>2151           with_scope(method_scoping, :overwrite, &block)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2152"></a>2152         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2153"></a>2153 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2154"></a>2154         def subclasses #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2155"></a>2155           @@subclasses[self] ||= []</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2156"></a>2156           @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2157"></a>2157         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2158"></a>2158 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2159"></a>2159         # Sets the default options for the model. The format of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2160"></a>2160         # <tt>options</tt> argument is the same as in find.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2161"></a>2161         #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2162"></a>2162         #   class Person < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2163"></a>2163         #     default_scope :order => 'last_name, first_name'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2164"></a>2164         #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2165"></a>2165         def default_scope(options = {})</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2166"></a>2166           self.default_scoping << { :find => options, :create => options[:conditions].is_a?(Hash) ? options[:conditions] : {} }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2167"></a>2167         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2168"></a>2168 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2169"></a>2169         # Test whether the given method and optional key are scoped.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2170"></a>2170         def scoped?(method, key = nil) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2171"></a>2171           if current_scoped_methods && (scope = current_scoped_methods[method])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2172"></a>2172             !key || !scope[key].nil?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2173"></a>2173           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2174"></a>2174         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2175"></a>2175 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2176"></a>2176         # Retrieve the scope for the given method and optional key.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2177"></a>2177         def scope(method, key = nil) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2178"></a>2178           if current_scoped_methods && (scope = current_scoped_methods[method])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2179"></a>2179             key ? scope[key] : scope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2180"></a>2180           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2181"></a>2181         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2182"></a>2182 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2183"></a>2183         def scoped_methods #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2184"></a>2184           Thread.current[:"#{self}_scoped_methods"] ||= self.default_scoping.dup</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2185"></a>2185         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2186"></a>2186 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2187"></a>2187         def current_scoped_methods #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2188"></a>2188           scoped_methods.last</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2189"></a>2189         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2190"></a>2190 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2191"></a>2191         # Returns the class type of the record using the current module as a prefix. So descendants of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2192"></a>2192         # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2193"></a>2193         def compute_type(type_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2194"></a>2194           modularized_name = type_name_with_module(type_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2195"></a>2195           silence_warnings do</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2196"></a>2196             begin</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2197"></a>2197               class_eval(modularized_name, __FILE__, __LINE__)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2198"></a>2198             rescue NameError</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2199"></a>2199               class_eval(type_name, __FILE__, __LINE__)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2200"></a>2200             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2201"></a>2201           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2202"></a>2202         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2203"></a>2203 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2204"></a>2204         # Returns the class descending directly from ActiveRecord::Base or an</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2205"></a>2205         # abstract class, if any, in the inheritance hierarchy.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2206"></a>2206         def class_of_active_record_descendant(klass)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2207"></a>2207           if klass.superclass == Base || klass.superclass.abstract_class?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2208"></a>2208             klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2209"></a>2209           elsif klass.superclass.nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2210"></a>2210             raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2211"></a>2211           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2212"></a>2212             class_of_active_record_descendant(klass.superclass)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2213"></a>2213           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2214"></a>2214         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2215"></a>2215 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2216"></a>2216         # Returns the name of the class descending directly from Active Record in the inheritance hierarchy.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2217"></a>2217         def class_name_of_active_record_descendant(klass) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2218"></a>2218           klass.base_class.name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2219"></a>2219         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2220"></a>2220 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2221"></a>2221         # Accepts an array, hash, or string of SQL conditions and sanitizes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2222"></a>2222         # them into a valid SQL fragment for a WHERE clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2223"></a>2223         #   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2224"></a>2224         #   { :name => "foo'bar", :group_id => 4 }  returns "name='foo''bar' and group_id='4'"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2225"></a>2225         #   "name='foo''bar' and group_id='4'" returns "name='foo''bar' and group_id='4'"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2226"></a>2226         def sanitize_sql_for_conditions(condition, table_name = quoted_table_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2227"></a>2227           return nil if condition.blank?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2228"></a>2228 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2229"></a>2229           case condition</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2230"></a>2230             when Array; sanitize_sql_array(condition)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2231"></a>2231             when Hash;  sanitize_sql_hash_for_conditions(condition, table_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2232"></a>2232             else        condition</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2233"></a>2233           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2234"></a>2234         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2235"></a>2235         alias_method :sanitize_sql, :sanitize_sql_for_conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2236"></a>2236 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2237"></a>2237         # Accepts an array, hash, or string of SQL conditions and sanitizes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2238"></a>2238         # them into a valid SQL fragment for a SET clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2239"></a>2239         #   { :name => nil, :group_id => 4 }  returns "name = NULL , group_id='4'"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2240"></a>2240         def sanitize_sql_for_assignment(assignments)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2241"></a>2241           case assignments</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2242"></a>2242             when Array; sanitize_sql_array(assignments)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2243"></a>2243             when Hash;  sanitize_sql_hash_for_assignment(assignments)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2244"></a>2244             else        assignments</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2245"></a>2245           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2246"></a>2246         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2247"></a>2247 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2248"></a>2248         def aggregate_mapping(reflection)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2249"></a>2249           mapping = reflection.options[:mapping] || [reflection.name, reflection.name]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2250"></a>2250           mapping.first.is_a?(Array) ? mapping : [mapping]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2251"></a>2251         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2252"></a>2252 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2253"></a>2253         # Accepts a hash of SQL conditions and replaces those attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2254"></a>2254         # that correspond to a +composed_of+ relationship with their expanded</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2255"></a>2255         # aggregate attribute values.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2256"></a>2256         # Given:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2257"></a>2257         #     class Person < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2258"></a>2258         #       composed_of :address, :class_name => "Address",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2259"></a>2259         #         :mapping => [%w(address_street street), %w(address_city city)]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2260"></a>2260         #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2261"></a>2261         # Then:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2262"></a>2262         #     { :address => Address.new("813 abc st.", "chicago") }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2263"></a>2263         #       # => { :address_street => "813 abc st.", :address_city => "chicago" }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2264"></a>2264         def expand_hash_conditions_for_aggregates(attrs)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2265"></a>2265           expanded_attrs = {}</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2266"></a>2266           attrs.each do |attr, value|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2267"></a>2267             unless (aggregation = reflect_on_aggregation(attr.to_sym)).nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2268"></a>2268               mapping = aggregate_mapping(aggregation)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2269"></a>2269               mapping.each do |field_attr, aggregate_attr|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2270"></a>2270                 if mapping.size == 1 && !value.respond_to?(aggregate_attr)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2271"></a>2271                   expanded_attrs[field_attr] = value</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2272"></a>2272                 else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2273"></a>2273                   expanded_attrs[field_attr] = value.send(aggregate_attr)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2274"></a>2274                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2275"></a>2275               end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2276"></a>2276             else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2277"></a>2277               expanded_attrs[attr] = value</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2278"></a>2278             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2279"></a>2279           end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2280"></a>2280           expanded_attrs</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2281"></a>2281         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2282"></a>2282 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2283"></a>2283         # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2284"></a>2284         #   { :name => "foo'bar", :group_id => 4 }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2285"></a>2285         #     # => "name='foo''bar' and group_id= 4"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2286"></a>2286         #   { :status => nil, :group_id => [1,2,3] }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2287"></a>2287         #     # => "status IS NULL and group_id IN (1,2,3)"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2288"></a>2288         #   { :age => 13..18 }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2289"></a>2289         #     # => "age BETWEEN 13 AND 18"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2290"></a>2290         #   { 'other_records.id' => 7 }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2291"></a>2291         #     # => "`other_records`.`id` = 7"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2292"></a>2292         #   { :other_records => { :id => 7 } }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2293"></a>2293         #     # => "`other_records`.`id` = 7"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2294"></a>2294         # And for value objects on a composed_of relationship:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2295"></a>2295         #   { :address => Address.new("123 abc st.", "chicago") }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2296"></a>2296         #     # => "address_street='123 abc st.' and address_city='chicago'"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2297"></a>2297         def sanitize_sql_hash_for_conditions(attrs, default_table_name = quoted_table_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2298"></a>2298           attrs = expand_hash_conditions_for_aggregates(attrs)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2299"></a>2299 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2300"></a>2300           conditions = attrs.map do |attr, value|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2301"></a>2301             table_name = default_table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2302"></a>2302 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2303"></a>2303             unless value.is_a?(Hash)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2304"></a>2304               attr = attr.to_s</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2305"></a>2305 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2306"></a>2306               # Extract table name from qualified attribute names.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2307"></a>2307               if attr.include?('.')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2308"></a>2308                 attr_table_name, attr = attr.split('.', 2)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2309"></a>2309                 attr_table_name = connection.quote_table_name(attr_table_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2310"></a>2310               else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2311"></a>2311                 attr_table_name = table_name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2312"></a>2312               end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2313"></a>2313 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2314"></a>2314               attribute_condition("#{attr_table_name}.#{connection.quote_column_name(attr)}", value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2315"></a>2315             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2316"></a>2316               sanitize_sql_hash_for_conditions(value, connection.quote_table_name(attr.to_s))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2317"></a>2317             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2318"></a>2318           end.join(' AND ')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2319"></a>2319 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2320"></a>2320           replace_bind_variables(conditions, expand_range_bind_variables(attrs.values))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2321"></a>2321         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2322"></a>2322         alias_method :sanitize_sql_hash, :sanitize_sql_hash_for_conditions</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2323"></a>2323 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2324"></a>2324         # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2325"></a>2325         #   { :status => nil, :group_id => 1 }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2326"></a>2326         #     # => "status = NULL , group_id = 1"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2327"></a>2327         def sanitize_sql_hash_for_assignment(attrs)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2328"></a>2328           attrs.map do |attr, value|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2329"></a>2329             "#{connection.quote_column_name(attr)} = #{quote_bound_value(value)}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2330"></a>2330           end.join(', ')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2331"></a>2331         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2332"></a>2332 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2333"></a>2333         # Accepts an array of conditions.  The array has each value</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2334"></a>2334         # sanitized and interpolated into the SQL statement.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2335"></a>2335         #   ["name='%s' and group_id='%s'", "foo'bar", 4]  returns  "name='foo''bar' and group_id='4'"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2336"></a>2336         def sanitize_sql_array(ary)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2337"></a>2337           statement, *values = ary</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2338"></a>2338           if values.first.is_a?(Hash) and statement =~ /:\w+/</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2339"></a>2339             replace_named_bind_variables(statement, values.first)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2340"></a>2340           elsif statement.include?('?')</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2341"></a>2341             replace_bind_variables(statement, values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2342"></a>2342           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2343"></a>2343             statement % values.collect { |value| connection.quote_string(value.to_s) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2344"></a>2344           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2345"></a>2345         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2346"></a>2346 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2347"></a>2347         alias_method :sanitize_conditions, :sanitize_sql</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2348"></a>2348 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2349"></a>2349         def replace_bind_variables(statement, values) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2350"></a>2350           raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2351"></a>2351           bound = values.dup</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2352"></a>2352           statement.gsub('?') { quote_bound_value(bound.shift) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2353"></a>2353         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2354"></a>2354 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2355"></a>2355         def replace_named_bind_variables(statement, bind_vars) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2356"></a>2356           statement.gsub(/(:?):([a-zA-Z]\w*)/) do</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2357"></a>2357             if $1 == ':' # skip postgresql casts</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2358"></a>2358               $& # return the whole match</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2359"></a>2359             elsif bind_vars.include?(match = $2.to_sym)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2360"></a>2360               quote_bound_value(bind_vars[match])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2361"></a>2361             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2362"></a>2362               raise PreparedStatementInvalid, "missing value for :#{match} in #{statement}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2363"></a>2363             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2364"></a>2364           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2365"></a>2365         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2366"></a>2366 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2367"></a>2367         def expand_range_bind_variables(bind_vars) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2368"></a>2368           expanded = []</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2369"></a>2369 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2370"></a>2370           bind_vars.each do |var|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2371"></a>2371             next if var.is_a?(Hash)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2372"></a>2372 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2373"></a>2373             if var.is_a?(Range)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2374"></a>2374               expanded << var.first</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2375"></a>2375               expanded << var.last</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2376"></a>2376             else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2377"></a>2377               expanded << var</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2378"></a>2378             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2379"></a>2379           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2380"></a>2380 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2381"></a>2381           expanded</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2382"></a>2382         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2383"></a>2383 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2384"></a>2384         def quote_bound_value(value) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2385"></a>2385           if value.respond_to?(:map) && !value.acts_like?(:string)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2386"></a>2386             if value.respond_to?(:empty?) && value.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2387"></a>2387               connection.quote(nil)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2388"></a>2388             else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2389"></a>2389               value.map { |v| connection.quote(v) }.join(',')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2390"></a>2390             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2391"></a>2391           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2392"></a>2392             connection.quote(value)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2393"></a>2393           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2394"></a>2394         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2395"></a>2395 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2396"></a>2396         def raise_if_bind_arity_mismatch(statement, expected, provided) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2397"></a>2397           unless expected == provided</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2398"></a>2398             raise PreparedStatementInvalid, "wrong number of bind variables (#{provided} for #{expected}) in: #{statement}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2399"></a>2399           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2400"></a>2400         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2401"></a>2401 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2402"></a>2402         VALID_FIND_OPTIONS = [ :conditions, :include, :joins, :limit, :offset,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2403"></a>2403                                :order, :select, :readonly, :group, :having, :from, :lock ]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2404"></a>2404 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2405"></a>2405         def validate_find_options(options) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2406"></a>2406           options.assert_valid_keys(VALID_FIND_OPTIONS)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2407"></a>2407         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2408"></a>2408 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2409"></a>2409         def set_readonly_option!(options) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2410"></a>2410           # Inherit :readonly from finder scope if set.  Otherwise,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2411"></a>2411           # if :joins is not blank then :readonly defaults to true.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2412"></a>2412           unless options.has_key?(:readonly)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2413"></a>2413             if scoped_readonly = scope(:find, :readonly)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2414"></a>2414               options[:readonly] = scoped_readonly</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2415"></a>2415             elsif !options[:joins].blank? && !options[:select]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2416"></a>2416               options[:readonly] = true</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2417"></a>2417             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2418"></a>2418           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2419"></a>2419         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2420"></a>2420 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2421"></a>2421         def encode_quoted_value(value) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2422"></a>2422           quoted_value = connection.quote(value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2423"></a>2423           quoted_value = "'#{quoted_value[1..-2].gsub(/\'/, "\\\\'")}'" if quoted_value.include?("\\\'") # (for ruby mode) "</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2424"></a>2424           quoted_value</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2425"></a>2425         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2426"></a>2426     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2427"></a>2427 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2428"></a>2428     public</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2429"></a>2429       # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2430"></a>2430       # attributes but not yet saved (pass a hash with key names matching the associated table column names).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2431"></a>2431       # In both instances, valid attribute keys are determined by the column names of the associated table --</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2432"></a>2432       # hence you can't have attributes that aren't part of the table columns.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2433"></a>2433       def initialize(attributes = nil)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2434"></a>2434         @attributes = attributes_from_column_definition</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2435"></a>2435         @attributes_cache = {}</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2436"></a>2436         @new_record = true</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2437"></a>2437         ensure_proper_type</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2438"></a>2438         self.attributes = attributes unless attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2439"></a>2439         self.class.send(:scope, :create).each { |att,value| self.send("#{att}=", value) } if self.class.send(:scoped?, :create)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2440"></a>2440         result = yield self if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2441"></a>2441         callback(:after_initialize) if respond_to_without_attributes?(:after_initialize)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2442"></a>2442         result</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2443"></a>2443       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2444"></a>2444 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2445"></a>2445       # A model instance's primary key is always available as model.id</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2446"></a>2446       # whether you name it the default 'id' or set it to something else.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2447"></a>2447       def id</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2448"></a>2448         attr_name = self.class.primary_key</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2449"></a>2449         column = column_for_attribute(attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2450"></a>2450 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2451"></a>2451         self.class.send(:define_read_method, :id, attr_name, column)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2452"></a>2452         # now that the method exists, call it</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2453"></a>2453         self.send attr_name.to_sym</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2454"></a>2454 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2455"></a>2455       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2456"></a>2456 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2457"></a>2457       # Returns a String, which Action Pack uses for constructing an URL to this</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2458"></a>2458       # object. The default implementation returns this record's id as a String,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2459"></a>2459       # or nil if this record's unsaved.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2460"></a>2460       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2461"></a>2461       # For example, suppose that you have a User model, and that you have a</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2462"></a>2462       # <tt>map.resources :users</tt> route. Normally, +user_path+ will</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2463"></a>2463       # construct a path with the user object's 'id' in it:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2464"></a>2464       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2465"></a>2465       #   user = User.find_by_name('Phusion')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2466"></a>2466       #   user_path(user)  # => "/users/1"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2467"></a>2467       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2468"></a>2468       # You can override +to_param+ in your model to make +user_path+ construct</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2469"></a>2469       # a path using the user's name instead of the user's id:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2470"></a>2470       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2471"></a>2471       #   class User < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2472"></a>2472       #     def to_param  # overridden</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2473"></a>2473       #       name</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2474"></a>2474       #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2475"></a>2475       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2476"></a>2476       #   </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2477"></a>2477       #   user = User.find_by_name('Phusion')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2478"></a>2478       #   user_path(user)  # => "/users/Phusion"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2479"></a>2479       def to_param</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2480"></a>2480         # We can't use alias_method here, because method 'id' optimizes itself on the fly.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2481"></a>2481         (id = self.id) ? id.to_s : nil # Be sure to stringify the id for routes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2482"></a>2482       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2483"></a>2483 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2484"></a>2484       # Returns a cache key that can be used to identify this record.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2485"></a>2485       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2486"></a>2486       # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2487"></a>2487       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2488"></a>2488       #   Product.new.cache_key     # => "products/new"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2489"></a>2489       #   Product.find(5).cache_key # => "products/5" (updated_at not available)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2490"></a>2490       #   Person.find(5).cache_key  # => "people/5-20071224150000" (updated_at available)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2491"></a>2491       def cache_key</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2492"></a>2492         case</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2493"></a>2493         when new_record?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2494"></a>2494           "#{self.class.model_name.cache_key}/new"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2495"></a>2495         when timestamp = self[:updated_at]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2496"></a>2496           "#{self.class.model_name.cache_key}/#{id}-#{timestamp.to_s(:number)}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2497"></a>2497         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2498"></a>2498           "#{self.class.model_name.cache_key}/#{id}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2499"></a>2499         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2500"></a>2500       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2501"></a>2501 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2502"></a>2502       def id_before_type_cast #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2503"></a>2503         read_attribute_before_type_cast(self.class.primary_key)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2504"></a>2504       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2505"></a>2505 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2506"></a>2506       def quoted_id #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2507"></a>2507         quote_value(id, column_for_attribute(self.class.primary_key))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2508"></a>2508       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2509"></a>2509 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2510"></a>2510       # Sets the primary ID.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2511"></a>2511       def id=(value)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2512"></a>2512         write_attribute(self.class.primary_key, value)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2513"></a>2513       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2514"></a>2514 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2515"></a>2515       # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet; otherwise, returns false.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2516"></a>2516       def new_record?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2517"></a>2517         @new_record || false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2518"></a>2518       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2519"></a>2519 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2520"></a>2520       # :call-seq:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2521"></a>2521       #   save(perform_validation = true)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2522"></a>2522       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2523"></a>2523       # Saves the model.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2524"></a>2524       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2525"></a>2525       # If the model is new a record gets created in the database, otherwise</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2526"></a>2526       # the existing record gets updated.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2527"></a>2527       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2528"></a>2528       # If +perform_validation+ is true validations run. If any of them fail</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2529"></a>2529       # the action is cancelled and +save+ returns +false+. If the flag is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2530"></a>2530       # false validations are bypassed altogether. See</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2531"></a>2531       # ActiveRecord::Validations for more information. </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2532"></a>2532       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2533"></a>2533       # There's a series of callbacks associated with +save+. If any of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2534"></a>2534       # <tt>before_*</tt> callbacks return +false+ the action is cancelled and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2535"></a>2535       # +save+ returns +false+. See ActiveRecord::Callbacks for further</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2536"></a>2536       # details. </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2537"></a>2537       def save</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2538"></a>2538         create_or_update</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2539"></a>2539       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2540"></a>2540 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2541"></a>2541       # Saves the model.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2542"></a>2542       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2543"></a>2543       # If the model is new a record gets created in the database, otherwise</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2544"></a>2544       # the existing record gets updated.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2545"></a>2545       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2546"></a>2546       # With <tt>save!</tt> validations always run. If any of them fail</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2547"></a>2547       # ActiveRecord::RecordInvalid gets raised. See ActiveRecord::Validations</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2548"></a>2548       # for more information. </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2549"></a>2549       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2550"></a>2550       # There's a series of callbacks associated with <tt>save!</tt>. If any of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2551"></a>2551       # the <tt>before_*</tt> callbacks return +false+ the action is cancelled</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2552"></a>2552       # and <tt>save!</tt> raises ActiveRecord::RecordNotSaved. See</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2553"></a>2553       # ActiveRecord::Callbacks for further details. </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2554"></a>2554       def save!</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2555"></a>2555         create_or_update || raise(RecordNotSaved)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2556"></a>2556       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2557"></a>2557 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2558"></a>2558       # Deletes the record in the database and freezes this instance to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2559"></a>2559       # reflect that no changes should be made (since they can't be</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2560"></a>2560       # persisted). Returns the frozen instance.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2561"></a>2561       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2562"></a>2562       # The row is simply removed with a SQL +DELETE+ statement on the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2563"></a>2563       # record's primary key, and no callbacks are executed.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2564"></a>2564       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2565"></a>2565       # To enforce the object's +before_destroy+ and +after_destroy+</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2566"></a>2566       # callbacks, Observer methods, or any <tt>:dependent</tt> association</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2567"></a>2567       # options, use <tt>#destroy</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2568"></a>2568       def delete</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2569"></a>2569         self.class.delete(id) unless new_record?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2570"></a>2570         freeze</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2571"></a>2571       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2572"></a>2572 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2573"></a>2573       # Deletes the record in the database and freezes this instance to reflect that no changes should</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2574"></a>2574       # be made (since they can't be persisted).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2575"></a>2575       def destroy</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2576"></a>2576         unless new_record?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2577"></a>2577           connection.delete(</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2578"></a>2578             "DELETE FROM #{self.class.quoted_table_name} " +</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2579"></a>2579             "WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quoted_id}",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2580"></a>2580             "#{self.class.name} Destroy"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2581"></a>2581           )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2582"></a>2582         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2583"></a>2583 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2584"></a>2584         freeze</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2585"></a>2585       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2586"></a>2586 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2587"></a>2587       # Returns a clone of the record that hasn't been assigned an id yet and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2588"></a>2588       # is treated as a new record.  Note that this is a "shallow" clone:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2589"></a>2589       # it copies the object's attributes only, not its associations.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2590"></a>2590       # The extent of a "deep" clone is application-specific and is therefore</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2591"></a>2591       # left to the application to implement according to its need.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2592"></a>2592       def clone</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2593"></a>2593         attrs = clone_attributes(:read_attribute_before_type_cast)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2594"></a>2594         attrs.delete(self.class.primary_key)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2595"></a>2595         record = self.class.new</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2596"></a>2596         record.send :instance_variable_set, '@attributes', attrs</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2597"></a>2597         record</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2598"></a>2598       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2599"></a>2599 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2600"></a>2600       # Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2601"></a>2601       # single-table inheritance structures where you want a subclass to appear as the superclass. This can be used along with record</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2602"></a>2602       # identification in Action Pack to allow, say, <tt>Client < Company</tt> to do something like render <tt>:partial => @client.becomes(Company)</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2603"></a>2603       # to render that instance using the companies/company partial instead of clients/client.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2604"></a>2604       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2605"></a>2605       # Note: The new instance will share a link to the same attributes as the original class. So any change to the attributes in either</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2606"></a>2606       # instance will affect the other.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2607"></a>2607       def becomes(klass)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2608"></a>2608         returning klass.new do |became|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2609"></a>2609           became.instance_variable_set("@attributes", @attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2610"></a>2610           became.instance_variable_set("@attributes_cache", @attributes_cache)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2611"></a>2611           became.instance_variable_set("@new_record", new_record?)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2612"></a>2612         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2613"></a>2613       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2614"></a>2614 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2615"></a>2615       # Updates a single attribute and saves the record without going through the normal validation procedure.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2616"></a>2616       # This is especially useful for boolean flags on existing records. The regular +update_attribute+ method</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2617"></a>2617       # in Base is replaced with this when the validations module is mixed in, which it is by default.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2618"></a>2618       def update_attribute(name, value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2619"></a>2619         send(name.to_s + '=', value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2620"></a>2620         save(false)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2621"></a>2621       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2622"></a>2622 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2623"></a>2623       # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2624"></a>2624       # fail and false will be returned.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2625"></a>2625       def update_attributes(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2626"></a>2626         self.attributes = attributes</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2627"></a>2627         save</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2628"></a>2628       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2629"></a>2629 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2630"></a>2630       # Updates an object just like Base.update_attributes but calls save! instead of save so an exception is raised if the record is invalid.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2631"></a>2631       def update_attributes!(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2632"></a>2632         self.attributes = attributes</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2633"></a>2633         save!</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2634"></a>2634       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2635"></a>2635 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2636"></a>2636       # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2637"></a>2637       # The increment is performed directly on the underlying attribute, no setter is invoked.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2638"></a>2638       # Only makes sense for number-based attributes. Returns +self+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2639"></a>2639       def increment(attribute, by = 1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2640"></a>2640         self[attribute] ||= 0</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2641"></a>2641         self[attribute] += by</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2642"></a>2642         self</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2643"></a>2643       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2644"></a>2644 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2645"></a>2645       # Wrapper around +increment+ that saves the record. This method differs from</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2646"></a>2646       # its non-bang version in that it passes through the attribute setter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2647"></a>2647       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2648"></a>2648       # record could be saved.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2649"></a>2649       def increment!(attribute, by = 1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2650"></a>2650         increment(attribute, by).update_attribute(attribute, self[attribute])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2651"></a>2651       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2652"></a>2652 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2653"></a>2653       # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2654"></a>2654       # The decrement is performed directly on the underlying attribute, no setter is invoked.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2655"></a>2655       # Only makes sense for number-based attributes. Returns +self+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2656"></a>2656       def decrement(attribute, by = 1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2657"></a>2657         self[attribute] ||= 0</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2658"></a>2658         self[attribute] -= by</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2659"></a>2659         self</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2660"></a>2660       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2661"></a>2661 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2662"></a>2662       # Wrapper around +decrement+ that saves the record. This method differs from</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2663"></a>2663       # its non-bang version in that it passes through the attribute setter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2664"></a>2664       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2665"></a>2665       # record could be saved.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2666"></a>2666       def decrement!(attribute, by = 1)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2667"></a>2667         decrement(attribute, by).update_attribute(attribute, self[attribute])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2668"></a>2668       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2669"></a>2669 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2670"></a>2670       # Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2671"></a>2671       # if the predicate returns +true+ the attribute will become +false+. This</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2672"></a>2672       # method toggles directly the underlying value without calling any setter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2673"></a>2673       # Returns +self+.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2674"></a>2674       def toggle(attribute)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2675"></a>2675         self[attribute] = !send("#{attribute}?")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2676"></a>2676         self</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2677"></a>2677       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2678"></a>2678 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2679"></a>2679       # Wrapper around +toggle+ that saves the record. This method differs from</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2680"></a>2680       # its non-bang version in that it passes through the attribute setter.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2681"></a>2681       # Saving is not subjected to validation checks. Returns +true+ if the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2682"></a>2682       # record could be saved.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2683"></a>2683       def toggle!(attribute)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2684"></a>2684         toggle(attribute).update_attribute(attribute, self[attribute])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2685"></a>2685       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2686"></a>2686 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2687"></a>2687       # Reloads the attributes of this object from the database.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2688"></a>2688       # The optional options argument is passed to find when reloading so you</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2689"></a>2689       # may do e.g. record.reload(:lock => true) to reload the same record with</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2690"></a>2690       # an exclusive row lock.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2691"></a>2691       def reload(options = nil)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2692"></a>2692         clear_aggregation_cache</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2693"></a>2693         clear_association_cache</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2694"></a>2694         @attributes.update(self.class.find(self.id, options).instance_variable_get('@attributes'))</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2695"></a>2695         @attributes_cache = {}</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2696"></a>2696         self</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2697"></a>2697       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2698"></a>2698 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2699"></a>2699       # Returns the value of the attribute identified by <tt>attr_name</tt> after it has been typecast (for example,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2700"></a>2700       # "2004-12-12" in a data column is cast to a date object, like Date.new(2004, 12, 12)).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2701"></a>2701       # (Alias for the protected read_attribute method).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2702"></a>2702       def [](attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2703"></a>2703         read_attribute(attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2704"></a>2704       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2705"></a>2705 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2706"></a>2706       # Updates the attribute identified by <tt>attr_name</tt> with the specified +value+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2707"></a>2707       # (Alias for the protected write_attribute method).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2708"></a>2708       def []=(attr_name, value)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2709"></a>2709         write_attribute(attr_name, value)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2710"></a>2710       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2711"></a>2711 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2712"></a>2712       # Allows you to set all the attributes at once by passing in a hash with keys</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2713"></a>2713       # matching the attribute names (which again matches the column names).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2714"></a>2714       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2715"></a>2715       # If +guard_protected_attributes+ is true (the default), then sensitive</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2716"></a>2716       # attributes can be protected from this form of mass-assignment by using</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2717"></a>2717       # the +attr_protected+ macro. Or you can alternatively specify which</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2718"></a>2718       # attributes *can* be accessed with the +attr_accessible+ macro. Then all the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2719"></a>2719       # attributes not included in that won't be allowed to be mass-assigned.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2720"></a>2720       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2721"></a>2721       #   class User < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2722"></a>2722       #     attr_protected :is_admin</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2723"></a>2723       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2724"></a>2724       #   </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2725"></a>2725       #   user = User.new</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2726"></a>2726       #   user.attributes = { :username => 'Phusion', :is_admin => true }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2727"></a>2727       #   user.username   # => "Phusion"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2728"></a>2728       #   user.is_admin?  # => false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2729"></a>2729       #   </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2730"></a>2730       #   user.send(:attributes=, { :username => 'Phusion', :is_admin => true }, false)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2731"></a>2731       #   user.is_admin?  # => true</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2732"></a>2732       def attributes=(new_attributes, guard_protected_attributes = true)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2733"></a>2733         return if new_attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2734"></a>2734         attributes = new_attributes.dup</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2735"></a>2735         attributes.stringify_keys!</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2736"></a>2736 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2737"></a>2737         multi_parameter_attributes = []</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2738"></a>2738         attributes = remove_attributes_protected_from_mass_assignment(attributes) if guard_protected_attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2739"></a>2739 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2740"></a>2740         attributes.each do |k, v|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2741"></a>2741           if k.include?("(")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2742"></a>2742             multi_parameter_attributes << [ k, v ]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2743"></a>2743           else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2744"></a>2744             respond_to?(:"#{k}=") ? send(:"#{k}=", v) : raise(UnknownAttributeError, "unknown attribute: #{k}")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2745"></a>2745           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2746"></a>2746         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2747"></a>2747 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2748"></a>2748         assign_multiparameter_attributes(multi_parameter_attributes)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2749"></a>2749       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2750"></a>2750 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2751"></a>2751       # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2752"></a>2752       def attributes</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2753"></a>2753         self.attribute_names.inject({}) do |attrs, name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2754"></a>2754           attrs[name] = read_attribute(name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2755"></a>2755           attrs</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2756"></a>2756         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2757"></a>2757       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2758"></a>2758 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2759"></a>2759       # Returns a hash of attributes before typecasting and deserialization.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2760"></a>2760       def attributes_before_type_cast</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2761"></a>2761         self.attribute_names.inject({}) do |attrs, name|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2762"></a>2762           attrs[name] = read_attribute_before_type_cast(name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2763"></a>2763           attrs</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2764"></a>2764         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2765"></a>2765       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2766"></a>2766 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2767"></a>2767       # Returns an <tt>#inspect</tt>-like string for the value of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2768"></a>2768       # attribute +attr_name+. String attributes are elided after 50</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2769"></a>2769       # characters, and Date and Time attributes are returned in the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2770"></a>2770       # <tt>:db</tt> format. Other attributes return the value of</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2771"></a>2771       # <tt>#inspect</tt> without modification.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2772"></a>2772       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2773"></a>2773       #   person = Person.create!(:name => "David Heinemeier Hansson " * 3)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2774"></a>2774       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2775"></a>2775       #   person.attribute_for_inspect(:name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2776"></a>2776       #   # => '"David Heinemeier Hansson David Heinemeier Hansson D..."'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2777"></a>2777       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2778"></a>2778       #   person.attribute_for_inspect(:created_at)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2779"></a>2779       #   # => '"2009-01-12 04:48:57"'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2780"></a>2780       def attribute_for_inspect(attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2781"></a>2781         value = read_attribute(attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2782"></a>2782 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2783"></a>2783         if value.is_a?(String) && value.length > 50</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2784"></a>2784           "#{value[0..50]}...".inspect</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2785"></a>2785         elsif value.is_a?(Date) || value.is_a?(Time)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2786"></a>2786           %("#{value.to_s(:db)}")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2787"></a>2787         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2788"></a>2788           value.inspect</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2789"></a>2789         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2790"></a>2790       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2791"></a>2791 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2792"></a>2792       # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2793"></a>2793       # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2794"></a>2794       def attribute_present?(attribute)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2795"></a>2795         value = read_attribute(attribute)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2796"></a>2796         !value.blank?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2797"></a>2797       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2798"></a>2798 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2799"></a>2799       # Returns true if the given attribute is in the attributes hash</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2800"></a>2800       def has_attribute?(attr_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2801"></a>2801         @attributes.has_key?(attr_name.to_s)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2802"></a>2802       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2803"></a>2803 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2804"></a>2804       # Returns an array of names for the attributes available on this object sorted alphabetically.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2805"></a>2805       def attribute_names</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2806"></a>2806         @attributes.keys.sort</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2807"></a>2807       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2808"></a>2808 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2809"></a>2809       # Returns the column object for the named attribute.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2810"></a>2810       def column_for_attribute(name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2811"></a>2811         self.class.columns_hash[name.to_s]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2812"></a>2812       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2813"></a>2813 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2814"></a>2814       # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2815"></a>2815       def ==(comparison_object)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2816"></a>2816         comparison_object.equal?(self) ||</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2817"></a>2817           (comparison_object.instance_of?(self.class) &&</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2818"></a>2818             comparison_object.id == id &&</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2819"></a>2819             !comparison_object.new_record?)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2820"></a>2820       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2821"></a>2821 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2822"></a>2822       # Delegates to ==</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2823"></a>2823       def eql?(comparison_object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2824"></a>2824         self == (comparison_object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2825"></a>2825       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2826"></a>2826 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2827"></a>2827       # Delegates to id in order to allow two records of the same type and id to work with something like:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2828"></a>2828       #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2829"></a>2829       def hash</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2830"></a>2830         id.hash</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2831"></a>2831       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2832"></a>2832 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2833"></a>2833       # Freeze the attributes hash such that associations are still accessible, even on destroyed records.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2834"></a>2834       def freeze</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2835"></a>2835         @attributes.freeze; self</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2836"></a>2836       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2837"></a>2837 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2838"></a>2838       # Returns +true+ if the attributes hash has been frozen.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2839"></a>2839       def frozen?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2840"></a>2840         @attributes.frozen?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2841"></a>2841       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2842"></a>2842 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2843"></a>2843       # Returns +true+ if the record is read only. Records loaded through joins with piggy-back</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2844"></a>2844       # attributes will be marked as read only since they cannot be saved.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2845"></a>2845       def readonly?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2846"></a>2846         defined?(@readonly) && @readonly == true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2847"></a>2847       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2848"></a>2848 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2849"></a>2849       # Marks this record as read only.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2850"></a>2850       def readonly!</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2851"></a>2851         @readonly = true</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2852"></a>2852       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2853"></a>2853 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2854"></a>2854       # Returns the contents of the record as a nicely formatted string.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2855"></a>2855       def inspect</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2856"></a>2856         attributes_as_nice_string = self.class.column_names.collect { |name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2857"></a>2857           if has_attribute?(name) || new_record?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2858"></a>2858             "#{name}: #{attribute_for_inspect(name)}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2859"></a>2859           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2860"></a>2860         }.compact.join(", ")</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2861"></a>2861         "#<#{self.class} #{attributes_as_nice_string}>"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2862"></a>2862       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2863"></a>2863 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2864"></a>2864     private</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2865"></a>2865       def create_or_update</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2866"></a>2866         raise ReadOnlyRecord if readonly?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2867"></a>2867         result = new_record? ? create : update</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2868"></a>2868         result != false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2869"></a>2869       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2870"></a>2870 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2871"></a>2871       # Updates the associated record with values matching those of the instance attributes.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2872"></a>2872       # Returns the number of affected rows.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2873"></a>2873       def update(attribute_names = @attributes.keys)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2874"></a>2874         quoted_attributes = attributes_with_quotes(false, false, attribute_names)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2875"></a>2875         return 0 if quoted_attributes.empty?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2876"></a>2876         connection.update(</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2877"></a>2877           "UPDATE #{self.class.quoted_table_name} " +</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2878"></a>2878           "SET #{quoted_comma_pair_list(connection, quoted_attributes)} " +</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2879"></a>2879           "WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quote_value(id)}",</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2880"></a>2880           "#{self.class.name} Update"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2881"></a>2881         )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2882"></a>2882       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2883"></a>2883 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2884"></a>2884       # Creates a record with values matching those of the instance attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2885"></a>2885       # and returns its id.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2886"></a>2886       def create</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2887"></a>2887         if self.id.nil? && connection.prefetch_primary_key?(self.class.table_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2888"></a>2888           self.id = connection.next_sequence_value(self.class.sequence_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2889"></a>2889         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2890"></a>2890 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2891"></a>2891         quoted_attributes = attributes_with_quotes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2892"></a>2892 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2893"></a>2893         statement = if quoted_attributes.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2894"></a>2894           connection.empty_insert_statement(self.class.table_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2895"></a>2895         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2896"></a>2896           "INSERT INTO #{self.class.quoted_table_name} " +</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2897"></a>2897           "(#{quoted_column_names.join(', ')}) " +</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2898"></a>2898           "VALUES(#{quoted_attributes.values.join(', ')})"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2899"></a>2899         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2900"></a>2900 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2901"></a>2901         self.id = connection.insert(statement, "#{self.class.name} Create",</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2902"></a>2902           self.class.primary_key, self.id, self.class.sequence_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2903"></a>2903 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2904"></a>2904         @new_record = false</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2905"></a>2905         id</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2906"></a>2906       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2907"></a>2907 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2908"></a>2908       # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendant.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2909"></a>2909       # Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to do Reply.new without having to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2910"></a>2910       # set <tt>Reply[Reply.inheritance_column] = "Reply"</tt> yourself. No such attribute would be set for objects of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2911"></a>2911       # Message class in that example.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2912"></a>2912       def ensure_proper_type</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2913"></a>2913         unless self.class.descends_from_active_record?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2914"></a>2914           write_attribute(self.class.inheritance_column, self.class.sti_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2915"></a>2915         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2916"></a>2916       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2917"></a>2917 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2918"></a>2918       def convert_number_column_value(value)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2919"></a>2919         if value == false</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2920"></a>2920           0</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2921"></a>2921         elsif value == true</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2922"></a>2922           1</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2923"></a>2923         elsif value.is_a?(String) && value.blank?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2924"></a>2924           nil</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2925"></a>2925         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2926"></a>2926           value</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2927"></a>2927         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2928"></a>2928       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2929"></a>2929 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2930"></a>2930       def remove_attributes_protected_from_mass_assignment(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2931"></a>2931         safe_attributes =</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2932"></a>2932           if self.class.accessible_attributes.nil? && self.class.protected_attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2933"></a>2933             attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2934"></a>2934           elsif self.class.protected_attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2935"></a>2935             attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, "")) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2936"></a>2936           elsif self.class.accessible_attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2937"></a>2937             attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,"")) || attributes_protected_by_default.include?(key.gsub(/\(.+/, "")) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2938"></a>2938           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2939"></a>2939             raise "Declare either attr_protected or attr_accessible for #{self.class}, but not both."</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2940"></a>2940           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2941"></a>2941 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2942"></a>2942         removed_attributes = attributes.keys - safe_attributes.keys</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2943"></a>2943 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2944"></a>2944         if removed_attributes.any?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2945"></a>2945           log_protected_attribute_removal(removed_attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2946"></a>2946         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2947"></a>2947 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2948"></a>2948         safe_attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2949"></a>2949       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2950"></a>2950 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2951"></a>2951       # Removes attributes which have been marked as readonly.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2952"></a>2952       def remove_readonly_attributes(attributes)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2953"></a>2953         unless self.class.readonly_attributes.nil?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2954"></a>2954           attributes.delete_if { |key, value| self.class.readonly_attributes.include?(key.gsub(/\(.+/,"")) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2955"></a>2955         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2956"></a>2956           attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2957"></a>2957         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2958"></a>2958       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2959"></a>2959 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2960"></a>2960       def log_protected_attribute_removal(*attributes)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2961"></a>2961         logger.debug "WARNING: Can't mass-assign these protected attributes: #{attributes.join(', ')}"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2962"></a>2962       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2963"></a>2963 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2964"></a>2964       # The primary key and inheritance column can never be set by mass-assignment for security reasons.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2965"></a>2965       def attributes_protected_by_default</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2966"></a>2966         default = [ self.class.primary_key, self.class.inheritance_column ]</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2967"></a>2967         default << 'id' unless self.class.primary_key.eql? 'id'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2968"></a>2968         default</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2969"></a>2969       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2970"></a>2970 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2971"></a>2971       # Returns a copy of the attributes hash where all the values have been safely quoted for use in</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2972"></a>2972       # an SQL statement.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2973"></a>2973       def attributes_with_quotes(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2974"></a>2974         quoted = {}</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2975"></a>2975         connection = self.class.connection</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2976"></a>2976         attribute_names.each do |name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2977"></a>2977           if (column = column_for_attribute(name)) && (include_primary_key || !column.primary)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2978"></a>2978             value = read_attribute(name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2979"></a>2979 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2980"></a>2980             # We need explicit to_yaml because quote() does not properly convert Time/Date fields to YAML.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2981"></a>2981             if value && self.class.serialized_attributes.has_key?(name) && (value.acts_like?(:date) || value.acts_like?(:time))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2982"></a>2982               value = value.to_yaml</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2983"></a>2983             end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2984"></a>2984 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2985"></a>2985             quoted[name] = connection.quote(value, column)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2986"></a>2986           end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2987"></a>2987         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2988"></a>2988         include_readonly_attributes ? quoted : remove_readonly_attributes(quoted)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2989"></a>2989       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2990"></a>2990 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2991"></a>2991       # Quote strings appropriately for SQL statements.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2992"></a>2992       def quote_value(value, column = nil)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2993"></a>2993         self.class.connection.quote(value, column)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2994"></a>2994       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2995"></a>2995 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2996"></a>2996       # Interpolate custom SQL string in instance context.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line2997"></a>2997       # Optional record argument is meant for custom insert_sql.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2998"></a>2998       def interpolate_sql(sql, record = nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line2999"></a>2999         instance_eval("%@#{sql.gsub('@', '\@')}@")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3000"></a>3000       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3001"></a>3001 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3002"></a>3002       # Initializes the attributes array with keys matching the columns from the linked table and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3003"></a>3003       # the values matching the corresponding default value of that column, so</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3004"></a>3004       # that a new instance, or one populated from a passed-in Hash, still has all the attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3005"></a>3005       # that instances loaded from the database would.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3006"></a>3006       def attributes_from_column_definition</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3007"></a>3007         self.class.columns.inject({}) do |attributes, column|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3008"></a>3008           attributes[column.name] = column.default unless column.name == self.class.primary_key</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3009"></a>3009           attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3010"></a>3010         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3011"></a>3011       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3012"></a>3012 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3013"></a>3013       # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3014"></a>3014       # by calling new on the column type or aggregation type (through composed_of) object with these parameters.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3015"></a>3015       # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3016"></a>3016       # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3017"></a>3017       # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3018"></a>3018       # s for String, and a for Array. If all the values for a given attribute are empty, the attribute will be set to nil.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3019"></a>3019       def assign_multiparameter_attributes(pairs)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3020"></a>3020         execute_callstack_for_multiparameter_attributes(</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3021"></a>3021           extract_callstack_for_multiparameter_attributes(pairs)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3022"></a>3022         )</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3023"></a>3023       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3024"></a>3024 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3025"></a>3025       def instantiate_time_object(name, values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3026"></a>3026         if self.class.send(:create_time_zone_conversion_attribute?, name, column_for_attribute(name))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3027"></a>3027           Time.zone.local(*values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3028"></a>3028         else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3029"></a>3029           Time.time_with_datetime_fallback(@@default_timezone, *values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3030"></a>3030         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3031"></a>3031       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3032"></a>3032 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3033"></a>3033       def execute_callstack_for_multiparameter_attributes(callstack)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3034"></a>3034         errors = []</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3035"></a>3035         callstack.each do |name, values_with_empty_parameters|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3036"></a>3036           begin</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3037"></a>3037             klass = (self.class.reflect_on_aggregation(name.to_sym) || column_for_attribute(name)).klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3038"></a>3038             # in order to allow a date to be set without a year, we must keep the empty values.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3039"></a>3039             # Otherwise, we wouldn't be able to distinguish it from a date with an empty day.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3040"></a>3040             values = values_with_empty_parameters.reject(&:nil?)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3041"></a>3041 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3042"></a>3042             if values.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3043"></a>3043               send(name + "=", nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3044"></a>3044             else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3045"></a>3045 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3046"></a>3046               value = if Time == klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3047"></a>3047                 instantiate_time_object(name, values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3048"></a>3048               elsif Date == klass</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3049"></a>3049                 begin</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3050"></a>3050                   values = values_with_empty_parameters.collect do |v| v.nil? ? 1 : v end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3051"></a>3051                   Date.new(*values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3052"></a>3052                 rescue ArgumentError => ex # if Date.new raises an exception on an invalid date</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3053"></a>3053                   instantiate_time_object(name, values).to_date # we instantiate Time object and convert it back to a date thus using Time's logic in handling invalid dates</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3054"></a>3054                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3055"></a>3055               else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3056"></a>3056                 klass.new(*values)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3057"></a>3057               end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3058"></a>3058 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3059"></a>3059               send(name + "=", value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3060"></a>3060             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3061"></a>3061           rescue => ex</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3062"></a>3062             errors << AttributeAssignmentError.new("error on assignment #{values.inspect} to #{name}", ex, name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3063"></a>3063           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3064"></a>3064         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3065"></a>3065         unless errors.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3066"></a>3066           raise MultiparameterAssignmentErrors.new(errors), "#{errors.size} error(s) on assignment of multiparameter attributes"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3067"></a>3067         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3068"></a>3068       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3069"></a>3069 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3070"></a>3070       def extract_callstack_for_multiparameter_attributes(pairs)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3071"></a>3071         attributes = { }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3072"></a>3072 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3073"></a>3073         for pair in pairs</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3074"></a>3074           multiparameter_name, value = pair</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3075"></a>3075           attribute_name = multiparameter_name.split("(").first</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3076"></a>3076           attributes[attribute_name] = [] unless attributes.include?(attribute_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3077"></a>3077 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3078"></a>3078           parameter_value = value.empty? ? nil : type_cast_attribute_value(multiparameter_name, value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3079"></a>3079           attributes[attribute_name] << [ find_parameter_position(multiparameter_name), parameter_value ]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3080"></a>3080         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3081"></a>3081 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3082"></a>3082         attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3083"></a>3083       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3084"></a>3084 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3085"></a>3085       def type_cast_attribute_value(multiparameter_name, value)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3086"></a>3086         multiparameter_name =~ /\([0-9]*([if])\)/ ? value.send("to_" + $1) : value</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3087"></a>3087       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3088"></a>3088 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3089"></a>3089       def find_parameter_position(multiparameter_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3090"></a>3090         multiparameter_name.scan(/\(([0-9]*).*\)/).first.first</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3091"></a>3091       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3092"></a>3092 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3093"></a>3093       # Returns a comma-separated pair list, like "key1 = val1, key2 = val2".</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3094"></a>3094       def comma_pair_list(hash)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3095"></a>3095         hash.inject([]) { |list, pair| list << "#{pair.first} = #{pair.last}" }.join(", ")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3096"></a>3096       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3097"></a>3097 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3098"></a>3098       def quoted_column_names(attributes = attributes_with_quotes)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3099"></a>3099         connection = self.class.connection</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3100"></a>3100         attributes.keys.collect do |column_name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3101"></a>3101           connection.quote_column_name(column_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3102"></a>3102         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3103"></a>3103       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3104"></a>3104 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3105"></a>3105       def self.quoted_table_name</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3106"></a>3106         self.connection.quote_table_name(self.table_name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3107"></a>3107       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3108"></a>3108 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3109"></a>3109       def quote_columns(quoter, hash)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3110"></a>3110         hash.inject({}) do |quoted, (name, value)|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3111"></a>3111           quoted[quoter.quote_column_name(name)] = value</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3112"></a>3112           quoted</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3113"></a>3113         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3114"></a>3114       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3115"></a>3115 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3116"></a>3116       def quoted_comma_pair_list(quoter, hash)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3117"></a>3117         comma_pair_list(quote_columns(quoter, hash))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3118"></a>3118       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3119"></a>3119 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3120"></a>3120       def object_from_yaml(string)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3121"></a>3121         return string unless string.is_a?(String) && string =~ /^---/</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3122"></a>3122         YAML::load(string) rescue string</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3123"></a>3123       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3124"></a>3124 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3125"></a>3125       def clone_attributes(reader_method = :read_attribute, attributes = {})</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3126"></a>3126         self.attribute_names.inject(attributes) do |attrs, name|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3127"></a>3127           attrs[name] = clone_attribute_value(reader_method, name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3128"></a>3128           attrs</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3129"></a>3129         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3130"></a>3130       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3131"></a>3131 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3132"></a>3132       def clone_attribute_value(reader_method, attribute_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3133"></a>3133         value = send(reader_method, attribute_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3134"></a>3134         value.duplicable? ? value.clone : value</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3135"></a>3135       rescue TypeError, NoMethodError</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3136"></a>3136         value</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3137"></a>3137       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line3138"></a>3138   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3139"></a>3139 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3140"></a>3140   Base.class_eval do</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3141"></a>3141     extend QueryCache::ClassMethods</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3142"></a>3142     include Validations</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3143"></a>3143     include Locking::Optimistic, Locking::Pessimistic</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3144"></a>3144     include AttributeMethods</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3145"></a>3145     include Dirty</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3146"></a>3146     include Callbacks, Observing, Timestamp</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3147"></a>3147     include Associations, AssociationPreload, NamedScope</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3148"></a>3148 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3149"></a>3149     # AutosaveAssociation needs to be included before Transactions, because we want</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3150"></a>3150     # #save_with_autosave_associations to be wrapped inside a transaction.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3151"></a>3151     include AutosaveAssociation, NestedAttributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3152"></a>3152 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3153"></a>3153     include Aggregations, Transactions, Reflection, Batches, Calculations, Serialization</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3154"></a>3154   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3155"></a>3155 end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3156"></a>3156 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line3157"></a>3157 # TODO: Remove this and make it work with LAZY flag</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3158"></a>3158 require 'active_record/connection_adapters/abstract_adapter'</pre></td>
        </tr>
      
      </tbody>
    </table>
    <hr/>
    <p>Generated on Thu Dec 17 11:11:17 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
  </body>
</html>
