<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/aggregations.rb</title>
    <link href="screen.css" media="screen" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h3>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/aggregations.rb</h3>
    <p>Generated on Thu Dec 17 11:11:16 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
    
    <hr />
      <pre>
        <span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here&apos;s a line marked as not executed.</span>
      </pre>
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <!-- alternate light/dark here -->
        <tr class='light'>
          <td>/Users/alainbloch/.gem/ruby/1.8/gems/activerecord-2.3.4/lib/active_record/aggregations.rb</td>
          <td class='lines_total'><tt>261</tt></td>
          <td class='lines_code'><tt>72</tt></td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_total'>75.86%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='76'></td>
                      <td class='uncovered' width='24'></td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_code'>19.44%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='19'/>
                      <td class='uncovered' width='81'/>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line1"></a>1 module ActiveRecord</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2"></a>2   module Aggregations # :nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3"></a>3     def self.included(base)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line4"></a>4       base.extend(ClassMethods)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line5"></a>5     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line6"></a>6 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line7"></a>7     def clear_aggregation_cache #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line8"></a>8       self.class.reflect_on_all_aggregations.to_a.each do |assoc|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line9"></a>9         instance_variable_set "@#{assoc.name}", nil</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line10"></a>10       end unless self.new_record?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line11"></a>11     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line12"></a>12 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line13"></a>13     # Active Record implements aggregation through a macro-like class method called +composed_of+ for representing attributes</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line14"></a>14     # as value objects. It expresses relationships like "Account [is] composed of Money [among other things]" or "Person [is]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line15"></a>15     # composed of [an] address". Each call to the macro adds a description of how the value objects are created from the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line16"></a>16     # attributes of the entity object (when the entity is initialized either as a new object or from finding an existing object)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line17"></a>17     # and how it can be turned back into attributes (when the entity is saved to the database). Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line18"></a>18     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line19"></a>19     #   class Customer < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line20"></a>20     #     composed_of :balance, :class_name => "Money", :mapping => %w(balance amount)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line21"></a>21     #     composed_of :address, :mapping => [ %w(address_street street), %w(address_city city) ]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line22"></a>22     #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line23"></a>23     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line24"></a>24     # The customer class now has the following methods to manipulate the value objects:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line25"></a>25     # * <tt>Customer#balance, Customer#balance=(money)</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line26"></a>26     # * <tt>Customer#address, Customer#address=(address)</tt></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line27"></a>27     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line28"></a>28     # These methods will operate with value objects like the ones described below:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line29"></a>29     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line30"></a>30     #  class Money</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line31"></a>31     #    include Comparable</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line32"></a>32     #    attr_reader :amount, :currency</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line33"></a>33     #    EXCHANGE_RATES = { "USD_TO_DKK" => 6 }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line34"></a>34     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line35"></a>35     #    def initialize(amount, currency = "USD")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line36"></a>36     #      @amount, @currency = amount, currency</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line37"></a>37     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line38"></a>38     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line39"></a>39     #    def exchange_to(other_currency)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line40"></a>40     #      exchanged_amount = (amount * EXCHANGE_RATES["#{currency}_TO_#{other_currency}"]).floor</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line41"></a>41     #      Money.new(exchanged_amount, other_currency)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line42"></a>42     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line43"></a>43     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line44"></a>44     #    def ==(other_money)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line45"></a>45     #      amount == other_money.amount && currency == other_money.currency</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line46"></a>46     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line47"></a>47     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line48"></a>48     #    def <=>(other_money)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line49"></a>49     #      if currency == other_money.currency</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line50"></a>50     #        amount <=> amount</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line51"></a>51     #      else</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line52"></a>52     #        amount <=> other_money.exchange_to(currency).amount</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line53"></a>53     #      end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line54"></a>54     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line55"></a>55     #  end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line56"></a>56     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line57"></a>57     #  class Address</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line58"></a>58     #    attr_reader :street, :city</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line59"></a>59     #    def initialize(street, city)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line60"></a>60     #      @street, @city = street, city</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line61"></a>61     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line62"></a>62     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line63"></a>63     #    def close_to?(other_address)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line64"></a>64     #      city == other_address.city</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line65"></a>65     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line66"></a>66     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line67"></a>67     #    def ==(other_address)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line68"></a>68     #      city == other_address.city && street == other_address.street</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line69"></a>69     #    end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line70"></a>70     #  end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line71"></a>71     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line72"></a>72     # Now it's possible to access attributes from the database through the value objects instead. If you choose to name the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line73"></a>73     # composition the same as the attribute's name, it will be the only way to access that attribute. That's the case with our</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line74"></a>74     # +balance+ attribute. You interact with the value objects just like you would any other attribute, though:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line75"></a>75     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line76"></a>76     #   customer.balance = Money.new(20)     # sets the Money value object and the attribute</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line77"></a>77     #   customer.balance                     # => Money value object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line78"></a>78     #   customer.balance.exchange_to("DKK")  # => Money.new(120, "DKK")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line79"></a>79     #   customer.balance > Money.new(10)     # => true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line80"></a>80     #   customer.balance == Money.new(20)    # => true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line81"></a>81     #   customer.balance < Money.new(5)      # => false</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line82"></a>82     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line83"></a>83     # Value objects can also be composed of multiple attributes, such as the case of Address. The order of the mappings will</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line84"></a>84     # determine the order of the parameters. Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line85"></a>85     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line86"></a>86     #   customer.address_street = "Hyancintvej"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line87"></a>87     #   customer.address_city   = "Copenhagen"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line88"></a>88     #   customer.address        # => Address.new("Hyancintvej", "Copenhagen")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line89"></a>89     #   customer.address = Address.new("May Street", "Chicago")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line90"></a>90     #   customer.address_street # => "May Street"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line91"></a>91     #   customer.address_city   # => "Chicago"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line92"></a>92     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line93"></a>93     # == Writing value objects</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line94"></a>94     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line95"></a>95     # Value objects are immutable and interchangeable objects that represent a given value, such as a Money object representing</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line96"></a>96     # $5. Two Money objects both representing $5 should be equal (through methods such as <tt>==</tt> and <tt><=></tt> from Comparable if ranking</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line97"></a>97     # makes sense). This is unlike entity objects where equality is determined by identity. An entity class such as Customer can</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line98"></a>98     # easily have two different objects that both have an address on Hyancintvej. Entity identity is determined by object or</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line99"></a>99     # relational unique identifiers (such as primary keys). Normal ActiveRecord::Base classes are entity objects.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line100"></a>100     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line101"></a>101     # It's also important to treat the value objects as immutable. Don't allow the Money object to have its amount changed after</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line102"></a>102     # creation. Create a new Money object with the new value instead. This is exemplified by the Money#exchange_to method that</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line103"></a>103     # returns a new value object instead of changing its own values. Active Record won't persist value objects that have been</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line104"></a>104     # changed through means other than the writer method.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line105"></a>105     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line106"></a>106     # The immutable requirement is enforced by Active Record by freezing any object assigned as a value object. Attempting to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line107"></a>107     # change it afterwards will result in a ActiveSupport::FrozenObjectError.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line108"></a>108     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line109"></a>109     # Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not keeping value objects</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line110"></a>110     # immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line111"></a>111     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line112"></a>112     # == Custom constructors and converters</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line113"></a>113     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line114"></a>114     # By default value objects are initialized by calling the <tt>new</tt> constructor of the value class passing each of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line115"></a>115     # mapped attributes, in the order specified by the <tt>:mapping</tt> option, as arguments. If the value class doesn't support</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line116"></a>116     # this convention then +composed_of+ allows a custom constructor to be specified.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line117"></a>117     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line118"></a>118     # When a new value is assigned to the value object the default assumption is that the new value is an instance of the value</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line119"></a>119     # class. Specifying a custom converter allows the new value to be automatically converted to an instance of value class if</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line120"></a>120     # necessary.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line121"></a>121     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line122"></a>122     # For example, the NetworkResource model has +network_address+ and +cidr_range+ attributes that should be aggregated using the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line123"></a>123     # NetAddr::CIDR value class (http://netaddr.rubyforge.org). The constructor for the value class is called +create+ and it</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line124"></a>124     # expects a CIDR address string as a parameter. New values can be assigned to the value object using either another</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line125"></a>125     # NetAddr::CIDR object, a string or an array. The <tt>:constructor</tt> and <tt>:converter</tt> options can be used to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line126"></a>126     # meet these requirements:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line127"></a>127     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line128"></a>128     #   class NetworkResource < ActiveRecord::Base</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line129"></a>129     #     composed_of :cidr,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line130"></a>130     #                 :class_name => 'NetAddr::CIDR',</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line131"></a>131     #                 :mapping => [ %w(network_address network), %w(cidr_range bits) ],</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line132"></a>132     #                 :allow_nil => true,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line133"></a>133     #                 :constructor => Proc.new { |network_address, cidr_range| NetAddr::CIDR.create("#{network_address}/#{cidr_range}") },</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line134"></a>134     #                 :converter => Proc.new { |value| NetAddr::CIDR.create(value.is_a?(Array) ? value.join('/') : value) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line135"></a>135     #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line136"></a>136     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line137"></a>137     #   # This calls the :constructor</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line138"></a>138     #   network_resource = NetworkResource.new(:network_address => '192.168.0.1', :cidr_range => 24)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line139"></a>139     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line140"></a>140     #   # These assignments will both use the :converter</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line141"></a>141     #   network_resource.cidr = [ '192.168.2.1', 8 ]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line142"></a>142     #   network_resource.cidr = '192.168.0.1/24'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line143"></a>143     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line144"></a>144     #   # This assignment won't use the :converter as the value is already an instance of the value class</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line145"></a>145     #   network_resource.cidr = NetAddr::CIDR.create('192.168.2.1/8')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line146"></a>146     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line147"></a>147     #   # Saving and then reloading will use the :constructor on reload</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line148"></a>148     #   network_resource.save</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line149"></a>149     #   network_resource.reload</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line150"></a>150     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line151"></a>151     # == Finding records by a value object</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line152"></a>152     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line153"></a>153     # Once a +composed_of+ relationship is specified for a model, records can be loaded from the database by specifying an instance</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line154"></a>154     # of the value object in the conditions hash. The following example finds all customers with +balance_amount+ equal to 20 and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line155"></a>155     # +balance_currency+ equal to "USD":</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line156"></a>156     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line157"></a>157     #   Customer.find(:all, :conditions => {:balance => Money.new(20, "USD")})</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line158"></a>158     #</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line159"></a>159     module ClassMethods</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line160"></a>160       # Adds reader and writer methods for manipulating a value object:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line161"></a>161       # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line162"></a>162       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line163"></a>163       # Options are:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line164"></a>164       # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name can't be inferred</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line165"></a>165       #   from the part id. So <tt>composed_of :address</tt> will by default be linked to the Address class, but</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line166"></a>166       #   if the real class name is CompanyAddress, you'll have to specify it with this option.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line167"></a>167       # * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value object. Each mapping</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line168"></a>168       #   is represented as an array where the first item is the name of the entity attribute and the second item is the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line169"></a>169       #   name the attribute in the value object. The order in which mappings are defined determine the order in which</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line170"></a>170       #   attributes are sent to the value class constructor.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line171"></a>171       # * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line172"></a>172       #   attributes are +nil+.  Setting the value object to +nil+ has the effect of writing +nil+ to all mapped attributes.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line173"></a>173       #   This defaults to +false+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line174"></a>174       # * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that is called to</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line175"></a>175       #   initialize the value object. The constructor is passed all of the mapped attributes, in the order that they</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line176"></a>176       #   are defined in the <tt>:mapping option</tt>, as arguments and uses them to instantiate a <tt>:class_name</tt> object.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line177"></a>177       #   The default is <tt>:new</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line178"></a>178       # * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt> or a Proc that is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line179"></a>179       #   called when a new value is assigned to the value object. The converter is passed the single value that is used</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line180"></a>180       #   in the assignment and is only called if the new value is not an instance of <tt>:class_name</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line181"></a>181       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line182"></a>182       # Option examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line183"></a>183       #   composed_of :temperature, :mapping => %w(reading celsius)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line184"></a>184       #   composed_of :balance, :class_name => "Money", :mapping => %w(balance amount), :converter => Proc.new { |balance| balance.to_money }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line185"></a>185       #   composed_of :address, :mapping => [ %w(address_street street), %w(address_city city) ]</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line186"></a>186       #   composed_of :gps_location</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line187"></a>187       #   composed_of :gps_location, :allow_nil => true</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line188"></a>188       #   composed_of :ip_address,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line189"></a>189       #               :class_name => 'IPAddr',</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line190"></a>190       #               :mapping => %w(ip to_i),</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line191"></a>191       #               :constructor => Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line192"></a>192       #               :converter => Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line193"></a>193       #</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line194"></a>194       def composed_of(part_id, options = {}, &block)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line195"></a>195         options.assert_valid_keys(:class_name, :mapping, :allow_nil, :constructor, :converter)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line196"></a>196 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line197"></a>197         name        = part_id.id2name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line198"></a>198         class_name  = options[:class_name]  || name.camelize</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line199"></a>199         mapping     = options[:mapping]     || [ name, name ]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line200"></a>200         mapping     = [ mapping ] unless mapping.first.is_a?(Array)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line201"></a>201         allow_nil   = options[:allow_nil]   || false</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line202"></a>202         constructor = options[:constructor] || :new</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line203"></a>203         converter   = options[:converter]   || block</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line204"></a>204 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line205"></a>205         ActiveSupport::Deprecation.warn('The conversion block has been deprecated, use the :converter option instead.', caller) if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line206"></a>206 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line207"></a>207         reader_method(name, class_name, mapping, allow_nil, constructor)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line208"></a>208         writer_method(name, class_name, mapping, allow_nil, converter)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line209"></a>209 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line210"></a>210         create_reflection(:composed_of, part_id, options, self)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line211"></a>211       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line212"></a>212 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line213"></a>213       private</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line214"></a>214         def reader_method(name, class_name, mapping, allow_nil, constructor)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line215"></a>215           module_eval do</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line216"></a>216             define_method(name) do |*args|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line217"></a>217               force_reload = args.first || false</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line218"></a>218               if (instance_variable_get("@#{name}").nil? || force_reload) && (!allow_nil || mapping.any? {|pair| !read_attribute(pair.first).nil? })</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line219"></a>219                 attrs = mapping.collect {|pair| read_attribute(pair.first)}</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line220"></a>220                 object = case constructor</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line221"></a>221                   when Symbol</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line222"></a>222                     class_name.constantize.send(constructor, *attrs)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line223"></a>223                   when Proc, Method</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line224"></a>224                     constructor.call(*attrs)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line225"></a>225                   else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line226"></a>226                     raise ArgumentError, 'Constructor must be a symbol denoting the constructor method to call or a Proc to be invoked.'</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line227"></a>227                   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line228"></a>228                 instance_variable_set("@#{name}", object)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line229"></a>229               end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line230"></a>230               instance_variable_get("@#{name}")</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line231"></a>231             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line232"></a>232           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line233"></a>233 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line234"></a>234         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line235"></a>235 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line236"></a>236         def writer_method(name, class_name, mapping, allow_nil, converter)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line237"></a>237           module_eval do</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line238"></a>238             define_method("#{name}=") do |part|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line239"></a>239               if part.nil? && allow_nil</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line240"></a>240                 mapping.each { |pair| self[pair.first] = nil }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line241"></a>241                 instance_variable_set("@#{name}", nil)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line242"></a>242               else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line243"></a>243                 unless part.is_a?(class_name.constantize) || converter.nil?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line244"></a>244                   part = case converter</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line245"></a>245                     when Symbol</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line246"></a>246                      class_name.constantize.send(converter, part)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line247"></a>247                     when Proc, Method</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line248"></a>248                       converter.call(part)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line249"></a>249                     else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line250"></a>250                       raise ArgumentError, 'Converter must be a symbol denoting the converter method to call or a Proc to be invoked.'</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line251"></a>251                     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line252"></a>252                 end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line253"></a>253                 mapping.each { |pair| self[pair.first] = part.send(pair.last) }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line254"></a>254                 instance_variable_set("@#{name}", part.freeze)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line255"></a>255               end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line256"></a>256             end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line257"></a>257           end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line258"></a>258         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line259"></a>259     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line260"></a>260   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line261"></a>261 end</pre></td>
        </tr>
      
      </tbody>
    </table>
    <hr/>
    <p>Generated on Thu Dec 17 11:11:16 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
  </body>
</html>
