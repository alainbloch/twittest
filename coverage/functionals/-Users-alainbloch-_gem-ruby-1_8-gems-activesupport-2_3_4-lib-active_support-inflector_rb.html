<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <title>/Users/alainbloch/.gem/ruby/1.8/gems/activesupport-2.3.4/lib/active_support/inflector.rb</title>
    <link href="screen.css" media="screen" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="rcov.js"></script>
  </head>
  <body>
    <h3>/Users/alainbloch/.gem/ruby/1.8/gems/activesupport-2.3.4/lib/active_support/inflector.rb</h3>
    <p>Generated on Thu Dec 17 11:11:20 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
    
    <hr />
      <pre>
        <span class='marked'>Code reported as executed by Ruby looks like this...</span><span class='marked1'>and this: this line is also marked as covered.</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this,</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).</span><span class='uncovered'>Finally, here&apos;s a line marked as not executed.</span>
      </pre>
    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <!-- alternate light/dark here -->
        <tr class='light'>
          <td>/Users/alainbloch/.gem/ruby/1.8/gems/activesupport-2.3.4/lib/active_support/inflector.rb</td>
          <td class='lines_total'><tt>406</tt></td>
          <td class='lines_code'><tt>177</tt></td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_total'>82.76%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='83'></td>
                      <td class='uncovered' width='17'></td>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td><tt class='coverage_code'>63.84%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='64'/>
                      <td class='uncovered' width='36'/>
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line1"></a>1 # encoding: utf-8</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line2"></a>2 require 'singleton'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line3"></a>3 require 'iconv'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line4"></a>4 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line5"></a>5 module ActiveSupport</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line6"></a>6   # The Inflector transforms words from singular to plural, class names to table names, modularized class names to ones without,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line7"></a>7   # and class names to foreign keys. The default inflections for pluralization, singularization, and uncountable words are kept</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line8"></a>8   # in inflections.rb.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line9"></a>9   #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line10"></a>10   # The Rails core team has stated patches for the inflections library will not be accepted</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line11"></a>11   # in order to avoid breaking legacy applications which may be relying on errant inflections.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line12"></a>12   # If you discover an incorrect inflection and require it for your application, you'll need</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line13"></a>13   # to correct it yourself (explained below).</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line14"></a>14   module Inflector</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line15"></a>15     extend self</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line16"></a>16 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line17"></a>17     # A singleton instance of this class is yielded by Inflector.inflections, which can then be used to specify additional</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line18"></a>18     # inflection rules. Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line19"></a>19     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line20"></a>20     #   ActiveSupport::Inflector.inflections do |inflect|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line21"></a>21     #     inflect.plural /^(ox)$/i, '\1\2en'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line22"></a>22     #     inflect.singular /^(ox)en/i, '\1'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line23"></a>23     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line24"></a>24     #     inflect.irregular 'octopus', 'octopi'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line25"></a>25     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line26"></a>26     #     inflect.uncountable "equipment"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line27"></a>27     #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line28"></a>28     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line29"></a>29     # New rules are added at the top. So in the example above, the irregular rule for octopus will now be the first of the</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line30"></a>30     # pluralization and singularization rules that is runs. This guarantees that your rules run before any of the rules that may</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line31"></a>31     # already have been loaded.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line32"></a>32     class Inflections</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line33"></a>33       include Singleton</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line34"></a>34 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line35"></a>35       attr_reader :plurals, :singulars, :uncountables, :humans</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line36"></a>36 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line37"></a>37       def initialize</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line38"></a>38         @plurals, @singulars, @uncountables, @humans = [], [], [], []</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line39"></a>39       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line40"></a>40 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line41"></a>41       # Specifies a new pluralization rule and its replacement. The rule can either be a string or a regular expression.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line42"></a>42       # The replacement should always be a string that may include references to the matched data from the rule.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line43"></a>43       def plural(rule, replacement)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line44"></a>44         @uncountables.delete(rule) if rule.is_a?(String)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line45"></a>45         @uncountables.delete(replacement)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line46"></a>46         @plurals.insert(0, [rule, replacement])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line47"></a>47       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line48"></a>48 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line49"></a>49       # Specifies a new singularization rule and its replacement. The rule can either be a string or a regular expression.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line50"></a>50       # The replacement should always be a string that may include references to the matched data from the rule.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line51"></a>51       def singular(rule, replacement)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line52"></a>52         @uncountables.delete(rule) if rule.is_a?(String)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line53"></a>53         @uncountables.delete(replacement)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line54"></a>54         @singulars.insert(0, [rule, replacement])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line55"></a>55       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line56"></a>56 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line57"></a>57       # Specifies a new irregular that applies to both pluralization and singularization at the same time. This can only be used</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line58"></a>58       # for strings, not regular expressions. You simply pass the irregular in singular and plural form.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line59"></a>59       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line60"></a>60       # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line61"></a>61       #   irregular 'octopus', 'octopi'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line62"></a>62       #   irregular 'person', 'people'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line63"></a>63       def irregular(singular, plural)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line64"></a>64         @uncountables.delete(singular)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line65"></a>65         @uncountables.delete(plural)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line66"></a>66         if singular[0,1].upcase == plural[0,1].upcase</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line67"></a>67           plural(Regexp.new("(#{singular[0,1]})#{singular[1..-1]}$", "i"), '\1' + plural[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line68"></a>68           singular(Regexp.new("(#{plural[0,1]})#{plural[1..-1]}$", "i"), '\1' + singular[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line69"></a>69         else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line70"></a>70           plural(Regexp.new("#{singular[0,1].upcase}(?i)#{singular[1..-1]}$"), plural[0,1].upcase + plural[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line71"></a>71           plural(Regexp.new("#{singular[0,1].downcase}(?i)#{singular[1..-1]}$"), plural[0,1].downcase + plural[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line72"></a>72           singular(Regexp.new("#{plural[0,1].upcase}(?i)#{plural[1..-1]}$"), singular[0,1].upcase + singular[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line73"></a>73           singular(Regexp.new("#{plural[0,1].downcase}(?i)#{plural[1..-1]}$"), singular[0,1].downcase + singular[1..-1])</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line74"></a>74         end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line75"></a>75       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line76"></a>76 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line77"></a>77       # Add uncountable words that shouldn't be attempted inflected.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line78"></a>78       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line79"></a>79       # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line80"></a>80       #   uncountable "money"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line81"></a>81       #   uncountable "money", "information"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line82"></a>82       #   uncountable %w( money information rice )</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line83"></a>83       def uncountable(*words)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line84"></a>84         (@uncountables << words).flatten!</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line85"></a>85       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line86"></a>86 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line87"></a>87       # Specifies a humanized form of a string by a regular expression rule or by a string mapping.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line88"></a>88       # When using a regular expression based replacement, the normal humanize formatting is called after the replacement.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line89"></a>89       # When a string is used, the human form should be specified as desired (example: 'The name', not 'the_name')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line90"></a>90       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line91"></a>91       # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line92"></a>92       #   human /_cnt$/i, '\1_count'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line93"></a>93       #   human "legacy_col_person_name", "Name"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line94"></a>94       def human(rule, replacement)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line95"></a>95         @humans.insert(0, [rule, replacement])</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line96"></a>96       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line97"></a>97 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line98"></a>98       # Clears the loaded inflections within a given scope (default is <tt>:all</tt>).</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line99"></a>99       # Give the scope as a symbol of the inflection type, the options are: <tt>:plurals</tt>,</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line100"></a>100       # <tt>:singulars</tt>, <tt>:uncountables</tt>, <tt>:humans</tt>.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line101"></a>101       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line102"></a>102       # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line103"></a>103       #   clear :all</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line104"></a>104       #   clear :plurals</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line105"></a>105       def clear(scope = :all)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line106"></a>106         case scope</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line107"></a>107           when :all</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line108"></a>108             @plurals, @singulars, @uncountables = [], [], []</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line109"></a>109           else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line110"></a>110             instance_variable_set "@#{scope}", []</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line111"></a>111         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line112"></a>112       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line113"></a>113     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line114"></a>114 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line115"></a>115     # Yields a singleton instance of Inflector::Inflections so you can specify additional</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line116"></a>116     # inflector rules.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line117"></a>117     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line118"></a>118     # Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line119"></a>119     #   ActiveSupport::Inflector.inflections do |inflect|</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line120"></a>120     #     inflect.uncountable "rails"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line121"></a>121     #   end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line122"></a>122     def inflections</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line123"></a>123       if block_given?</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line124"></a>124         yield Inflections.instance</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line125"></a>125       else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line126"></a>126         Inflections.instance</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line127"></a>127       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line128"></a>128     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line129"></a>129 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line130"></a>130     # Returns the plural form of the word in the string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line131"></a>131     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line132"></a>132     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line133"></a>133     #   "post".pluralize             # => "posts"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line134"></a>134     #   "octopus".pluralize          # => "octopi"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line135"></a>135     #   "sheep".pluralize            # => "sheep"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line136"></a>136     #   "words".pluralize            # => "words"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line137"></a>137     #   "CamelOctopus".pluralize     # => "CamelOctopi"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line138"></a>138     def pluralize(word)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line139"></a>139       result = word.to_s.dup</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line140"></a>140 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line141"></a>141       if word.empty? || inflections.uncountables.include?(result.downcase)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line142"></a>142         result</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line143"></a>143       else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line144"></a>144         inflections.plurals.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line145"></a>145         result</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line146"></a>146       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line147"></a>147     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line148"></a>148 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line149"></a>149     # The reverse of +pluralize+, returns the singular form of a word in a string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line150"></a>150     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line151"></a>151     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line152"></a>152     #   "posts".singularize            # => "post"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line153"></a>153     #   "octopi".singularize           # => "octopus"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line154"></a>154     #   "sheep".singluarize            # => "sheep"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line155"></a>155     #   "word".singularize             # => "word"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line156"></a>156     #   "CamelOctopi".singularize      # => "CamelOctopus"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line157"></a>157     def singularize(word)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line158"></a>158       result = word.to_s.dup</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line159"></a>159 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line160"></a>160       if inflections.uncountables.include?(result.downcase)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line161"></a>161         result</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line162"></a>162       else</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line163"></a>163         inflections.singulars.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line164"></a>164         result</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line165"></a>165       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line166"></a>166     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line167"></a>167 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line168"></a>168     # By default, +camelize+ converts strings to UpperCamelCase. If the argument to +camelize+</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line169"></a>169     # is set to <tt>:lower</tt> then +camelize+ produces lowerCamelCase.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line170"></a>170     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line171"></a>171     # +camelize+ will also convert '/' to '::' which is useful for converting paths to namespaces.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line172"></a>172     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line173"></a>173     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line174"></a>174     #   "active_record".camelize                # => "ActiveRecord"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line175"></a>175     #   "active_record".camelize(:lower)        # => "activeRecord"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line176"></a>176     #   "active_record/errors".camelize         # => "ActiveRecord::Errors"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line177"></a>177     #   "active_record/errors".camelize(:lower) # => "activeRecord::Errors"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line178"></a>178     def camelize(lower_case_and_underscored_word, first_letter_in_uppercase = true)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line179"></a>179       if first_letter_in_uppercase</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line180"></a>180         lower_case_and_underscored_word.to_s.gsub(/\/(.?)/) { "::#{$1.upcase}" }.gsub(/(?:^|_)(.)/) { $1.upcase }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line181"></a>181       else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line182"></a>182         lower_case_and_underscored_word.first.downcase + camelize(lower_case_and_underscored_word)[1..-1]</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line183"></a>183       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line184"></a>184     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line185"></a>185 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line186"></a>186     # Capitalizes all the words and replaces some characters in the string to create</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line187"></a>187     # a nicer looking title. +titleize+ is meant for creating pretty output. It is not</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line188"></a>188     # used in the Rails internals.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line189"></a>189     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line190"></a>190     # +titleize+ is also aliased as as +titlecase+.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line191"></a>191     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line192"></a>192     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line193"></a>193     #   "man from the boondocks".titleize # => "Man From The Boondocks"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line194"></a>194     #   "x-men: the last stand".titleize  # => "X Men: The Last Stand"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line195"></a>195     def titleize(word)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line196"></a>196       humanize(underscore(word)).gsub(/\b('?[a-z])/) { $1.capitalize }</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line197"></a>197     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line198"></a>198 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line199"></a>199     # The reverse of +camelize+. Makes an underscored, lowercase form from the expression in the string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line200"></a>200     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line201"></a>201     # Changes '::' to '/' to convert namespaces to paths.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line202"></a>202     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line203"></a>203     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line204"></a>204     #   "ActiveRecord".underscore         # => "active_record"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line205"></a>205     #   "ActiveRecord::Errors".underscore # => active_record/errors</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line206"></a>206     def underscore(camel_cased_word)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line207"></a>207       camel_cased_word.to_s.gsub(/::/, '/').</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line208"></a>208         gsub(/([A-Z]+)([A-Z][a-z])/,'\1_\2').</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line209"></a>209         gsub(/([a-z\d])([A-Z])/,'\1_\2').</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line210"></a>210         tr("-", "_").</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line211"></a>211         downcase</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line212"></a>212     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line213"></a>213 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line214"></a>214     # Replaces underscores with dashes in the string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line215"></a>215     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line216"></a>216     # Example:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line217"></a>217     #   "puni_puni" # => "puni-puni"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line218"></a>218     def dasherize(underscored_word)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line219"></a>219       underscored_word.gsub(/_/, '-')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line220"></a>220     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line221"></a>221 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line222"></a>222     # Capitalizes the first word and turns underscores into spaces and strips a</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line223"></a>223     # trailing "_id", if any. Like +titleize+, this is meant for creating pretty output.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line224"></a>224     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line225"></a>225     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line226"></a>226     #   "employee_salary" # => "Employee salary"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line227"></a>227     #   "author_id"       # => "Author"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line228"></a>228     def humanize(lower_case_and_underscored_word)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line229"></a>229       result = lower_case_and_underscored_word.to_s.dup</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line230"></a>230 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line231"></a>231       inflections.humans.each { |(rule, replacement)| break if result.gsub!(rule, replacement) }</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line232"></a>232       result.gsub(/_id$/, "").gsub(/_/, " ").capitalize</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line233"></a>233     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line234"></a>234 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line235"></a>235     # Removes the module part from the expression in the string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line236"></a>236     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line237"></a>237     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line238"></a>238     #   "ActiveRecord::CoreExtensions::String::Inflections".demodulize # => "Inflections"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line239"></a>239     #   "Inflections".demodulize                                       # => "Inflections"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line240"></a>240     def demodulize(class_name_in_module)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line241"></a>241       class_name_in_module.to_s.gsub(/^.*::/, '')</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line242"></a>242     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line243"></a>243 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line244"></a>244     # Replaces special characters in a string so that it may be used as part of a 'pretty' URL.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line245"></a>245     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line246"></a>246     # ==== Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line247"></a>247     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line248"></a>248     #   class Person</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line249"></a>249     #     def to_param</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line250"></a>250     #       "#{id}-#{name.parameterize}"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line251"></a>251     #     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line252"></a>252     #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line253"></a>253     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line254"></a>254     #   @person = Person.find(1)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line255"></a>255     #   # => #<Person id: 1, name: "Donald E. Knuth"></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line256"></a>256     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line257"></a>257     #   <%= link_to(@person.name, person_path(@person)) %></pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line258"></a>258     #   # => <a href="/person/1-donald-e-knuth">Donald E. Knuth</a></pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line259"></a>259     def parameterize(string, sep = '-')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line260"></a>260       # replace accented chars with ther ascii equivalents</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line261"></a>261       parameterized_string = transliterate(string)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line262"></a>262       # Turn unwanted chars into the seperator</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line263"></a>263       parameterized_string.gsub!(/[^a-z0-9\-_\+]+/i, sep)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line264"></a>264       unless sep.blank?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line265"></a>265         re_sep = Regexp.escape(sep)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line266"></a>266         # No more than one of the separator in a row.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line267"></a>267         parameterized_string.gsub!(/#{re_sep}{2,}/, sep)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line268"></a>268         # Remove leading/trailing separator.</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line269"></a>269         parameterized_string.gsub!(/^#{re_sep}|#{re_sep}$/i, '')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line270"></a>270       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line271"></a>271       parameterized_string.downcase</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line272"></a>272     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line273"></a>273 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line274"></a>274 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line275"></a>275     # Replaces accented characters with their ascii equivalents.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line276"></a>276     def transliterate(string)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line277"></a>277       Iconv.iconv('ascii//ignore//translit', 'utf-8', string).to_s</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line278"></a>278     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line279"></a>279 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line280"></a>280     if RUBY_VERSION >= '1.9'</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line281"></a>281       undef_method :transliterate</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line282"></a>282       def transliterate(string)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line283"></a>283         warn "Ruby 1.9 doesn't support Unicode normalization yet"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line284"></a>284         string.dup</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line285"></a>285       end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line286"></a>286 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line287"></a>287     # The iconv transliteration code doesn't function correctly</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line288"></a>288     # on some platforms, but it's very fast where it does function.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line289"></a>289     elsif "foo" != (Inflector.transliterate("föö") rescue nil)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line290"></a>290       undef_method :transliterate</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line291"></a>291       def transliterate(string)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line292"></a>292         string.mb_chars.normalize(:kd). # Decompose accented characters</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line293"></a>293           gsub(/[^\x00-\x7F]+/, '')     # Remove anything non-ASCII entirely (e.g. diacritics).</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line294"></a>294       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line295"></a>295     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line296"></a>296 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line297"></a>297     # Create the name of a table like Rails does for models to table names. This method</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line298"></a>298     # uses the +pluralize+ method on the last word in the string.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line299"></a>299     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line300"></a>300     # Examples</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line301"></a>301     #   "RawScaledScorer".tableize # => "raw_scaled_scorers"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line302"></a>302     #   "egg_and_ham".tableize     # => "egg_and_hams"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line303"></a>303     #   "fancyCategory".tableize   # => "fancy_categories"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line304"></a>304     def tableize(class_name)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line305"></a>305       pluralize(underscore(class_name))</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line306"></a>306     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line307"></a>307 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line308"></a>308     # Create a class name from a plural table name like Rails does for table names to models.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line309"></a>309     # Note that this returns a string and not a Class. (To convert to an actual class</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line310"></a>310     # follow +classify+ with +constantize+.)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line311"></a>311     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line312"></a>312     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line313"></a>313     #   "egg_and_hams".classify # => "EggAndHam"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line314"></a>314     #   "posts".classify        # => "Post"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line315"></a>315     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line316"></a>316     # Singular names are not handled correctly:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line317"></a>317     #   "business".classify     # => "Busines"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line318"></a>318     def classify(table_name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line319"></a>319       # strip out any leading schema name</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line320"></a>320       camelize(singularize(table_name.to_s.sub(/.*\./, '')))</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line321"></a>321     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line322"></a>322 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line323"></a>323     # Creates a foreign key name from a class name.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line324"></a>324     # +separate_class_name_and_id_with_underscore+ sets whether</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line325"></a>325     # the method should put '_' between the name and 'id'.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line326"></a>326     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line327"></a>327     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line328"></a>328     #   "Message".foreign_key        # => "message_id"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line329"></a>329     #   "Message".foreign_key(false) # => "messageid"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line330"></a>330     #   "Admin::Post".foreign_key    # => "post_id"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line331"></a>331     def foreign_key(class_name, separate_class_name_and_id_with_underscore = true)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line332"></a>332       underscore(demodulize(class_name)) + (separate_class_name_and_id_with_underscore ? "_id" : "id")</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line333"></a>333     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line334"></a>334 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line335"></a>335     # Ruby 1.9 introduces an inherit argument for Module#const_get and</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line336"></a>336     # #const_defined? and changes their default behavior.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line337"></a>337     if Module.method(:const_get).arity == 1</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line338"></a>338       # Tries to find a constant with the name specified in the argument string:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line339"></a>339       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line340"></a>340       #   "Module".constantize     # => Module</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line341"></a>341       #   "Test::Unit".constantize # => Test::Unit</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line342"></a>342       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line343"></a>343       # The name is assumed to be the one of a top-level constant, no matter whether</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line344"></a>344       # it starts with "::" or not. No lexical context is taken into account:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line345"></a>345       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line346"></a>346       #   C = 'outside'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line347"></a>347       #   module M</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line348"></a>348       #     C = 'inside'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line349"></a>349       #     C               # => 'inside'</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line350"></a>350       #     "C".constantize # => 'outside', same as ::C</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line351"></a>351       #   end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line352"></a>352       #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line353"></a>353       # NameError is raised when the name is not in CamelCase or the constant is</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line354"></a>354       # unknown.</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line355"></a>355       def constantize(camel_cased_word)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line356"></a>356         names = camel_cased_word.split('::')</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line357"></a>357         names.shift if names.empty? || names.first.empty?</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line358"></a>358 </pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line359"></a>359         constant = Object</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line360"></a>360         names.each do |name|</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line361"></a>361           constant = constant.const_defined?(name) ? constant.const_get(name) : constant.const_missing(name)</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line362"></a>362         end</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line363"></a>363         constant</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line364"></a>364       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line365"></a>365     else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line366"></a>366       def constantize(camel_cased_word) #:nodoc:</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line367"></a>367         names = camel_cased_word.split('::')</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line368"></a>368         names.shift if names.empty? || names.first.empty?</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line369"></a>369 </pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line370"></a>370         constant = Object</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line371"></a>371         names.each do |name|</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line372"></a>372           constant = constant.const_get(name, false) || constant.const_missing(name)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line373"></a>373         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line374"></a>374         constant</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line375"></a>375       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line376"></a>376     end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line377"></a>377 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line378"></a>378     # Turns a number into an ordinal string used to denote the position in an</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line379"></a>379     # ordered sequence such as 1st, 2nd, 3rd, 4th.</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line380"></a>380     #</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line381"></a>381     # Examples:</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line382"></a>382     #   ordinalize(1)     # => "1st"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line383"></a>383     #   ordinalize(2)     # => "2nd"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line384"></a>384     #   ordinalize(1002)  # => "1002nd"</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line385"></a>385     #   ordinalize(1003)  # => "1003rd"</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line386"></a>386     def ordinalize(number)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line387"></a>387       if (11..13).include?(number.to_i % 100)</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line388"></a>388         "#{number}th"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line389"></a>389       else</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line390"></a>390         case number.to_i % 10</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line391"></a>391           when 1; "#{number}st"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line392"></a>392           when 2; "#{number}nd"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line393"></a>393           when 3; "#{number}rd"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line394"></a>394           else    "#{number}th"</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line395"></a>395         end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line396"></a>396       end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line397"></a>397     end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line398"></a>398   end</pre></td>
        </tr>
      
        
        
        <tr class="uncovered">
          <td colspan="5"><pre><a name="line399"></a>399 end</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line400"></a>400 </pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line401"></a>401 # in case active_support/inflector is required without the rest of active_support</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line402"></a>402 require 'active_support/inflections'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line403"></a>403 require 'active_support/core_ext/string/inflections'</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line404"></a>404 unless String.included_modules.include?(ActiveSupport::CoreExtensions::String::Inflections)</pre></td>
        </tr>
      
        
        
        <tr class="marked">
          <td colspan="5"><pre><a name="line405"></a>405   String.send :include, ActiveSupport::CoreExtensions::String::Inflections</pre></td>
        </tr>
      
        
        
        <tr class="inferred">
          <td colspan="5"><pre><a name="line406"></a>406 end</pre></td>
        </tr>
      
      </tbody>
    </table>
    <hr/>
    <p>Generated on Thu Dec 17 11:11:20 -0800 2009 with <a href="http://github.com/relevance/rcov">rcov 0.8.3.4</a></p>
  </body>
</html>
